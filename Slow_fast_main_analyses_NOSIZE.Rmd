---
title: "Trait synergies"
output:
  html_document:
    df_print: paged
  pdf_document: default
---

Exploration of the trait analysis for trait synchrony.

```{r echo = F}
options(error = function(){    # Beep on error
  beepr::beep()
  Sys.sleep(1)
  }
 )

.Last <- function() {          # Beep on exiting session
  beepr::beep()
  Sys.sleep(1)
}
knitr::opts_knit$set(root.dir = "/Users/Margot/Desktop/Research/Senckenberg/Project_Ecosystem_strat/Analysis/Code")

```

```{r Setup, echo = FALSE, include = FALSE}

#remotes::install_github("allanecology/BetaDivMultifun")

library(forcats)
library(ade4)
library(factoextra)
library(ggfortify)
library(ggcorrplot)
library(lavaan)
library(semPlot)
library(ghibli)
library(mice)
library(miceFast)
library(ggnetwork)
library(viridis)
library(tidyverse)
library(tidygraph)
library(ggraph)
library(lavaan)
library(ggpmisc)
library(semTable)
library(FactoMineR)
library(data.table)
library(readxl)
library(kableExtra)
library(phyloseq)
library(BetaDivMultifun)
library(parameters)
library(beepr)

# Set working directory
#setwd("/Users/Margot/Desktop/Research/Senckenberg/Project_Ecosystem_strat/Analysis/Code")
env_corr <- TRUE 
weight = TRUE

seed = 101

pal.fnc = colorRamp(c('#4575b4','#91bfdb','#e0f3f8','#fee090','#fc8d59',
                      '#d73027'))

# Function to correct for region and/or environment
corrections <- function(CWM_data, Env_data = NULL, env_corr = FALSE,  variables = NULL, env_variables = NULL) {
  CWM_data_copy <- CWM_data[complete.cases(CWM_data),]
  if (env_corr == TRUE & is.null(Env_data)) {
    stop("Please provide environmental data")
  }
  
  if (is.null(variables)) {
    variables <- colnames(CWM_data_copy)[!(colnames(CWM_data_copy) %in% c("Plot", "Year"))]
  }
  
  if (is.null(env_variables)) {
    env_variables <- colnames(Env_data)[!(colnames(Env_data) %in% c("Plot", "Year"))]
  }
  
  
  if (env_corr == TRUE) {
    CWM_data_copy <- merge(CWM_data_copy, Env_data[, .SD, .SDcols = c("Plot", env_variables)], by = "Plot")
    
    CWM_data_copy[, (variables) := lapply(.SD, function(x) {
      mod <- lm(x ~ ., CWM_data_copy[, .SD, .SDcols = env_variables])
      return(residuals(mod))
    }),
    .SDcols = variables
    ]
    CWM_data_copy = CWM_data_copy[, .SD, .SDcols = c(variables, 'Plot')]
  }
  return(CWM_data_copy)
}

corrections_long <- function(value, env_data, env_corr = FALSE) {
  if (env_corr == TRUE) {
    mod <- lm(value ~ ., env_data)
    return(residuals(mod))
  } else {
    return(value)
  }
}

calculate_coeff_new = function(DATA){
  mod = 'value ~ Fertil 
         value ~ Mowing
         value ~ Grazing
      
      Mowing ~~ Fertil 
      Grazing ~~ Fertil 
      Grazing ~~ Mowing
'
  sem_components = sem(mod, data = DATA)
  res = as.list(partable(sem_components)$est[1:3])
  names(res) = partable(sem_components)$rhs[1:3]
  
  lui_mod = lm(value ~ LUI, data = DATA)
  parameters = model_parameters(lui_mod)
  res$estimate = parameters$Coefficient[2]
  res$p = parameters$p[2]
  res$ci_low =  parameters$CI_low[2]
  res$ci_high = parameters$CI_high[2]
  res$ci =  paste(res$ci_low,res$ci_high, sep = ' - ')
  res$n =  nobs(lui_mod)

  #lui_mod_uncorr = lm(value_uncorr ~ LUI, data = DATA)
  #coeff = coefficients(summary(lui_mod_uncorr))[2,]
  #res$estimate_uncorr = coeff['Estimate']
  #res$p_uncorr = coeff['Pr(>|t|)']
  #res$ci_uncorr = paste(round(confint(lui_mod_uncorr)[2,], 2), collapse = ' - ')
  
  return(res)
}

my_dudi_pca <- function(CWM_matrix, col_to_use, NF = 3) {
  matrix <- data.frame(CWM_matrix[complete.cases(CWM_matrix[, ..col_to_use])])
  rownames(matrix) <- matrix$Plot
  pca <- dudi.pca(matrix[, col_to_use], scannf = FALSE, nf = NF)
  return(pca)
}
scale01 = function(x){
  return((x-min(x))/(max(x)-min(x)))
}

# Function to change the direction of PCA axis (for reproductibility of axes direction)
axes_direction_pca <- function(pca, cwm, traitnames, conditions) {
  if (length(conditions) != length(traitnames)) {
    print("Number of axes, traits, and conditions should be equal")
  }
  else {
    cond_positive <- ifelse(gsub(" ", "", conditions) == ">0", TRUE, FALSE)
    I <- length(traitnames)
    for (i in 1:I) {
      if ((pca$li[cwm[get(traitnames[i]) == max(get(traitnames[i])), Plot], i] > 0) != cond_positive[i]) {
        #   print(paste("Changed direction of axis", i))
        pca$li[, i] <- -pca$li[, i]
        pca$co[, i] <- -pca$co[, i]
      }
    }
  }
  return(pca)
}



print_table = function(Hypo_table){
  #Hypo_table[, Group := droplevels(Group)]
  Table_use = Hypo_table[,.SD, .SDcols = c("Trait_short", "Expected_direction", "Direct/indirect", "Disturbance",	"ref_dist",	"Resources",	"ref_res", 'Est','CI','Padj', 'Fit_exp','Mowing', 'Grazing', 'Fertil'
                                           
  )]
  H_kable <- kable_paper(kbl(Table_use, escape = FALSE))
  
  H_kable <- column_spec(H_kable, which(colnames(Table_use) == "Est"),
                         background = rgb(pal.fnc(scale01(Hypo_table$Est)), maxColorValue=255),
                         color = 'white',
                         bold  = Hypo_table$Signif == "YES",
                         italic  = !Hypo_table$Signif == "no"
  )
  
  
  max.val = max(Hypo_table[, c('Mowing', 'Grazing', 'Fertil')])
  H_kable <- column_spec(H_kable, which(colnames(Table_use) == "Mowing"),
                         color  = rgb(pal.fnc(scale01(Hypo_table$Mowing)), maxColorValue=255))
  H_kable <- column_spec(H_kable, which(colnames(Table_use) == "Grazing"),
                         color =  rgb(pal.fnc(scale01(Hypo_table$Grazing)), maxColorValue=255))
  H_kable <- column_spec(H_kable, which(colnames(Table_use) == "Fertil"),
                         color  =  rgb(pal.fnc(scale01(Hypo_table$Fertil )), maxColorValue=255))
  
 # H_kable <- column_spec(H_kable, which(colnames(Table_use) == "Est_nocorr"),
 #                        background = rgb(pal.fnc(scale01(Hypo_table$Est_nocorr)), maxColorValue=255),
 #                        color = 'white',
 #                        bold  = Hypo_table$Signif == "YES",
 #                        italic  = !Hypo_table$Signif == "no"
 # )
  
  H_kable <- column_spec(H_kable, which(colnames(Table_use) == "Fit_exp"),
                         background = ifelse(is.na(Hypo_table$Fit_exp) | Hypo_table$Fit_exp == 'Inconclusive', 'grey', 'white')
  )
  #H_kable <- column_spec(H_kable, which(colnames(Table_use) == "Fit_exp_nocorr"),
  #                       background = ifelse(is.na(Hypo_table$Fit_exp_nocorr) | Hypo_table$Fit_exp_nocorr == 'Inconclusive', 'grey', 'white')
  #)
  
  
  H_kable = gsub( '+', '&#43;', H_kable, fixed = T)
  H_kable = gsub( '@@@', '&#', H_kable)
  H_kable %>% pack_rows(index = table(as.character(Hypo_table$Group)))
  
}

```

Parameters: environmental correction is `r env_corr`.

```{r Data input, echo = FALSE, include = FALSE}
# Environment data (LUI 2008-2017) ####
data_lui <- fread("Data/Environment_function_data/LUI_standardized_global.txt") 

# Check intra v. inter plot variation in LUI
#VP = varpart(data_lui[Year > 2007 & Year <= 2018, LUI], data_lui[Year > 2007 & Year <= 2018, factor(PLOTID)],data_lui[Year > 2007 & Year <= 2018, factor(Year)])
#modLUI = lm(LUI ~ factor(PLOTID)*factor(Year), data = data_lui)

data_lui = data_lui[Year > 2007 & Year <= 2018, list(LUI = mean(LUI),
                           Mowing = mean(M_STD),
                           Fertil = mean(F_STD),
                           Grazing = mean(G_STD)), by = list(Plot = ifelse(nchar(PLOTID) == 5,PLOTID, paste(substr(PLOTID, 1, 3), '0', substr(PLOTID, 4, 4), sep = '')))]
data_lui[, c('Fertilisation', 'Disturbance') := list( Fertil, sqrt(Mowing/mean(Mowing) + Grazing/mean(Grazing)))]


env_data <- data.table(read_excel("Data/Environment_function_data/31018_5_Dataset/31018_5_data.xslx", sheet = 1))
env_data[, Plot := EP_PlotID]
env_data_lui = merge.data.table(data_lui, env_data[, c('Plot', 'LII',   "Soil.pH", "Soil.depth", "Soil.clay.content" , "Soil.sand.content", "TWI" , 'Grassland.1000')], by = 'Plot')
      Temp = fread("Data/Environment_function_data/Ta_200_2008_2018_3a7aa69b37636254/plots.csv")
      Precip = fread("Data/Environment_function_data/precipitation_radolan_95a5c5f55a798133/plots.csv")
      Climate_data <- merge.data.table(Temp[, plotID := gsub('f', '', plotID)], Precip, by = c('plotID', 'datetime'))
      Climate_data[, Plot := plotID]
      Climate <- Climate_data[datetime>=2008 & datetime <= 2018, list("Mean_Temp" = mean(Ta_200, na.rm = T), "Mean_precip" = mean(precipitation_radolan, na.rm = T)), by = list("Plot" = plotID)]

env_data_lui = merge.data.table(env_data_lui, Climate, by = 'Plot')
  env_data_lui$Region = substr(env_data_lui$Plot, 1, 1)
env_var = c("Soil.pH", #"Soil.depth", 
            "Soil.clay.content", #, "Soil.sand.content", 
            "TWI", 'Mean_Temp'#,'Mean_precip'
            )
env_data_lui[, (c(env_var, 'LUI', 'Mowing', 'Fertil', 'Grazing')) := lapply(.SD, function(x){as.numeric(scale(x))}), .SDcols = c(env_var, 'LUI', 'Mowing', 'Fertil', 'Grazing')]
#env_var = c(env_var, 'Region')

if (weight == TRUE){
all_cwm_raw = fread('Data/CWM_data/All_CWM_data.csv')}
if (weight == FALSE){
all_cwm_raw = fread('Data/CWM_data/All_CWM_data_noweight.csv')}

traits_to_use = traits_use=c( # birds
       "birds_logBody_Mass",        "birds_logIncub_time",       "birds_logLongevity" ,            "birds_logBrood",    'birds_GenLength',          
 
  # Bats
  "bats_logBody_mass"  ,         "bats_Lifespan"                , 'bats_Number_offspring',             
  
  # Plants 
  "plants_Fine_roots_diameter", "plants_LDMC", "plants_LeafN", "plants_LeafP", "plants_Root_tissue_density", "plants_SLA_all", "plants_Seed_mass",
             # Most arthropods
  "arthropods_below_omni_carni_Dispersal_ability", "arthropods_below_omni_carni_logBody_Size", 
"arthropods_below_herb_Dispersal_ability", "arthropods_below_herb_logBody_Size", 
"arthropods_below_herb_Feeding_generalism", "arthropods_above_carni_Dispersal_ability", 
"arthropods_above_carni_logBody_Size", "arthropods_above_herb_Dispersal_ability", 
"arthropods_above_herb_logBody_Size", "arthropods_above_herb_Feeding_generalism", 
"arthropods_above_herb_Generations", 
              # Butterflies
"butterflies_logFlight", 'butterflies_logSize',
"butterflies_Wintering_stage", "butterflies_Generalism_use", 
"butterflies_Voltinism_use", 
              # Collembola and mites 
"coll_logSize", "coll_Gen_per_year", "coll_Depth_preference",  "coll_Repro_sex", 
"mites_logMass", "mites_Feeding_spec", 
"mites_Habitat_spec", "mites_Repro_sex", 
"mites_DaystoAdult", 
              # Bacteria and fungi
 "bact_fungi_logVolume", "bact_fungi_OC_ratio", "bact_fungi_FB_ratio", "bact_fungi_pathogens", 'bact_fungi_Genome_size',
              # Protists
"protists_sec_cons_Size", "protists_bact_Size",  "protists_nutrition_code_primary_cons"
)

all_cwm_raw = all_cwm_raw[traitName2 %in% traits_to_use & grepl('G', Plot),]
 # This one will be used to calculate correlations with LUI, group-level PCAs, and non-miced main PCA (for the SI), it should be corrected for the environment but not miced

all_cwm = copy(all_cwm_raw) # This one will be used to run PCAs to feed into the big PCA and SEM, it is miced and corrected for the environment
all_traits = unique(all_cwm_raw$traitName2)

# Aggregate by plot
all_cwm_agg = all_cwm_raw[Year != 2020 , list(traitValue = mean(traitValue, na.rm = T), traitCoverage = mean(traitCoverage, na.rm = T)), by = c('Plot', 'traitName','Group', 'traitName2')]
all_cwm_agg[!is.na(traitValue), length(unique(Plot)), by = Group] # plots available for use

# Add environmental covariates
all_cwm_lui = merge.data.table(all_cwm_agg, env_data_lui) 

# Scale all trait data
all_cwm_lui[, traitValue := scale(traitValue), by =c('Group','traitName2')]
all_cwm_lui = all_cwm_lui[order(Group, traitName2, Plot),]
# Mice with env corr as covariates (except LUI)
mice_long = function(traitname, covar, data){
  print(nrow(data))
  all_var_cast = dcast.data.table(data, ... ~ traitName2, value.var = 'traitValue', .SDcols = c(traitname, covar, 'Plot'))
  all_var_mice = data.table(mice::complete(mice(all_var_cast, printFlag = FALSE, seed = 101)))
  all_var_melt =  melt.data.table(all_var_mice, id.vars = c(covar, 'Plot'), value.name = 'traitValue', variable.name = 'traitName2')
    print(nrow(all_var_melt))

  return(all_var_melt[order(traitName2, Plot), traitValue])
}

all_cwm_lui[, traitValue2 := mice_long(traitName2, env_var, .SD), .SDcols = c('traitName2', 'traitValue', env_var, 'Plot'), by = Group]
# check
# ggplot(all_cwm_lui[Group == 'Bact_fun'], aes(traitValue2, traitValue)) + geom_point() + facet_wrap(~Group)

# Correct for environmental covariateq
all_cwm_lui[, traitValue3 := corrections_long(traitValue2, .SD, env_corr), .SDcols = c(env_var, 'Region'), by = c('Group', 'traitName')]
# check
#ggplot(all_cwm_lui, aes(traitValue3, traitValue2)) + geom_point() + facet_wrap(~Group)

all_cwm_lui[, value := traitValue3]

 # We can also put back as NA the miced values
all_cwm_lui_not_imputed = copy(all_cwm_lui)
all_cwm_lui_not_imputed[is.na(traitValue), value := NA]

 # This is the imputed dataset
all_cwm = dcast.data.table( all_cwm_lui, Plot  + LUI + Disturbance + Fertilisation~ traitName2, value.var = 'value' )
all_cwm_not_imputed = dcast.data.table(all_cwm_lui_not_imputed, Plot  + LUI + Disturbance + Fertilisation~ traitName2, value.var = 'value' )
```

```{r Mini SEMs, echo = FALSE, include = FALSE}
 LUI_component_effect = all_cwm_lui_not_imputed[, calculate_coeff_new(.SD), by = traitName2, .SDcols = c('Grazing', 'Mowing','Fertil', 'Fertilisation', 'Disturbance','value', #'value_uncorr', 
 'LUI')]

```

## Hypotheses

Check all hypotheses between traits and environmental drivers, and among traits
```{r Create hypothesis table, echo = FALSE, eval = TRUE}

#corr_mat <- cor(all_cwm[, .SD, .SDcols = c(all_traits, env_var, 'LUI', 'Fertil','Productivity' )], use = "pairwise.complete.obs")
#corr_pmat <- cor_pmat(all_cwm[, .SD, .SDcols = c(all_traits, env_var, env_var, 'LUI', 'Fertil','Productivity')], use = "pairwise.complete.obs")

#corr_mat_uncorr <- cor(all_cwm_uncorr[, .SD, .SDcols = c(all_traits,env_var, 'LUI', 'Fertil','Productivity')], use = "pairwise.complete.obs")
#corr_pmat_uncorr <- cor_pmat(all_cwm_uncorr[, .SD, .SDcols = c(all_traits,env_var,env_var, 'LUI', 'Fertil','Productivity')], use = "pairwise.complete.obs")

Hypothesis_table = fread('Hypotheses.txt')

Hypothesis_table = Hypothesis_table[Trait_short %in% LUI_component_effect$traitName2 & Use =='y',]

Hypothesis_table[, nrows := 1:nrow(Hypothesis_table)]

# Adding values
Hypothesis_table[Group != '', c("P", "Est", "CI","CI_low", 'CI_high', 'N', 'Mowing', 'Grazing', 'Fertil'#, 'P_uncorr', 'Est_nocorr', 'CI_nocorr'
                                ) :=
  list(
    round(LUI_component_effect[traitName2 == Trait_short, p], 5),
    round(LUI_component_effect[traitName2 == Trait_short, estimate], 2),
    LUI_component_effect[traitName2 == Trait_short, ci],
    LUI_component_effect[traitName2 == Trait_short, ci_low],
    LUI_component_effect[traitName2 == Trait_short, ci_high],
    LUI_component_effect[traitName2 == Trait_short, n],
    round(LUI_component_effect[traitName2 == Trait_short, Mowing], 2),
    round(LUI_component_effect[traitName2 == Trait_short, Grazing], 2),
    round(LUI_component_effect[traitName2 == Trait_short, Fertil ], 2)#,
    #round(LUI_component_effect[variable == Trait_short, p_uncorr], 5),
    #round(LUI_component_effect[variable == Trait_short, estimate_uncorr], 2),
    #LUI_component_effect[variable == Trait_short, ci_uncorr]
    ), by = nrows]
    
  Hypothesis_table[,c('Direction'#, 'Direction_uncorr'
                      ) := list(
     ifelse(Expected_direction == '+/-',  ifelse(Est > 0, 'a', 'b'),
         ifelse((Est > 0 & Expected_direction ==  "++") | (Est < 0 & Expected_direction ==  "--"), "yes", "no"))#,
   #   ifelse(Expected_direction == '+/-',  ifelse(Est_nocorr > 0, 'a', 'b')#,
   #      ifelse((Est_nocorr > 0 & Expected_direction ==  "++") | (Est_nocorr < 0 & Expected_direction ==  "--"), "yes", "no"))
      )]

  Hypothesis_table[, Padj := p.adjust(P, 'fdr')]
Hypothesis_table[, Signif := ifelse(Padj < 0.05, 'YES', ifelse(P < 0.05, 'yes', 'no'))]


    Hypothesis_table[,c('Fit_expectations') := list(
     ifelse(Padj > 0.05, 'Inconclusive',
            ifelse(Expected_direction == '+/-',  ifelse(Est > 0, 'As expected (fast)', 'As expected (slow)'),
         ifelse(Est > 0 & Expected_direction ==  "++",  'As expected (fast)',
             ifelse(Est < 0 & Expected_direction ==  "--", 'As expected (slow)', "Not expected"))))#,
   #   ifelse(Expected_direction == '+/-',  ifelse(Est_nocorr > 0, 'a', 'b')#,
   #      ifelse((Est_nocorr > 0 & Expected_direction ==  "++") | (Est_nocorr < 0 & Expected_direction ==  "--"), "yes", "no"))
      )]


#Hypothesis_table[, Padj_uncorr := p.adjust(P_uncorr, 'fdr')]
#Hypothesis_table[, Signif_no_env_corr := ifelse(Padj_uncorr < 0.05, 'YES', ifelse(P_uncorr < 0.05, 'yes', 'no'))]

return_hypo_result_color = function(Signif, Direction){
  res = NA
                                          if (Signif == 'no'){
                                            res = 'Inconclusive' } 
                                           if (Signif == 'yes'){
                                             if (Direction %in% c('a', 'b')) {res = Direction}
                                             if (Direction %in% c('yes', 'no')) {res = ifelse(Direction == "yes", "@@@10004;", "X")}  }
                                             if (Signif == 'YES'){
                                             if (Direction %in% c('a', 'b')) {res = toupper(Direction)}
                                             if (Direction %in% c('yes', 'no')) {res = ifelse(Direction == "yes", "@@@9989;", "@@@10060;")} }
  
return(res)}


Hypothesis_table[,  Fit_exp := return_hypo_result_color(Signif, Direction), by = 1:nrow(Hypothesis_table)]

#Hypothesis_table[,  Fit_exp_nocorr := return_hypo_result(Signif_no_env_corr, Direction), by = 1:nrow(Hypothesis_table)]

responding_traits = Hypothesis_table[ Fit_exp != 'Inconclusive' & Direction != "no", Trait_short]
print_table(Hypothesis_table)
```



## Big PCA

```{r Big PCA with all traits, echo = FALSE, eval = T, warning=FALSE, fig.show="hold", out.width="80%"}

#all_cwm_miced <- copy(data.table(all_cwm))
#all_cwm_miced$Plot = all_cwm$Plot

```

## Identification of strategy axes for each group

```{r, echo = FALSE, warning=FALSE, eval = T,fig.show="hold", out.width="50%"}
# Function to auto run PCAs
run_group_pca = function(cwm, traits, trait_direction, direction = '>0', plot = TRUE, env_corr, Labels = NA, annot = NA, naxes = 2){
   pca_stand = my_dudi_pca(cwm, traits)
   pca_stand = axes_direction_pca(pca, cwm, trait_direction, direction) # Correcting the direction of axes so that all slow>fat gos from left to right
  
   naxes = length(traits)
   
    corr_unsignificant = 0
    for (trait in traits){
     cor = cor.test(unlist(cwm[, ..trait]), pca$l1$RS1)
    if (cor$p.value > 0.05){
      corr_unsignificant = corr_unsignificant+1
    }
   }

   
   keep_criteria = data.table('More_than_random' = pca$eig[1] / (1/length(traits)),
                              'Prop.traits.40' =   length(pca$c1$CS1[abs(pca$c1$CS1)>0.4])/length(pca$c1$CS1),
                              'Prop.traits.25' =   length(pca$c1$CS1[abs(pca$c1$CS1)>0.25])/length(pca$c1$CS1),
                              'Cor_unsignificant' =  corr_unsignificant)
   keep_criteria[, enough_support := More_than_random >2 & Prop.traits.40 >= 0.60]
   keep_criteria[, partial := More_than_random >2 & Prop.traits.25 >= 0.60 & Cor_unsignificant <= 1]
   keep_criteria[, LUI.Axis1 := round(cor.test(cwm$LUI, pca$l1$RS1)$p.value, 3)]
   keep_criteria[, LUI.Axis2 := round(cor.test(cwm$LUI, pca$l1$RS2)$p.value, 3)]


   quanti.coord <- supcol(pca, scale(env_data_lui[Plot %in% cwm$Plot, .SD, .SDcols = c('LUI', 'Fertilisation', 'Disturbance')]))$cosup
   quanti.coord$Lab = c('LUI', 'Fertilisation', 'Disturbance')
   print(quanti.coord)

    for (i in 1:2) { 
       if (sum(pca_stand$li[, i] == -pca$li[, i]) != 0) { 
         # If the direction of the pca was changed then we also change the direction of the supcol
       quanti.coord[, i] <- -quanti.coord[, i]
       }}
        
        
if(any(is.na(Labels))){
  Labels = traits
}
  names(Labels)  = traits

if (is.na(annot)){
  Criteria_label = ifelse(keep_criteria$enough_support, 'Criteria met', 'Criteria not met!')
  if (keep_criteria$partial == TRUE & keep_criteria$enough_support != TRUE){
    Criteria_label = paste('Criteria partially met', sep = ' ')
  }
  
  Criteria_label = paste(Criteria_label, '\n Axis1 x LUI: p =', keep_criteria$LUI.Axis1,
                         '\n Axis2 x LUI: p =', keep_criteria$LUI.Axis2, sep = '')
}else{
  Criteria_label =  annot
}


plot_pca_12 = fviz_pca(pca_stand, title = '', geom = 'point', geom.var = c("arrow", 'text'), habillage = substr(env_data_lui$Region, 1, 1), labelsize = 3, repel = T)
plot_pca_12 =  fviz_add(plot_pca_12, quanti.coord, axes = c(1, 2), "arrow", color = "black", linetype = "solid", geom.var = c("arrow"), addlabel = TRUE, repel = T,  labelsize = 3)+
  scale_shape_discrete( breaks = c('A', 'H', 'S'), labels = c('South', 'Central', 'North'), name = 'Region')+
  scale_color_viridis(discrete = TRUE, begin = 0.3, breaks = c('A', 'H', 'S'), labels = c('South', 'Central', 'North'), name = 'Region') +
  annotate(geom = 'label', x = -Inf, y =+Inf, label = Criteria_label, hjust = -0.1, vjust = 1.5)


     if (naxes >= 3){
     plot_pca_13 <- fviz_pca(pca_stand, habillage = substr(cwm$Plot, 1, 1), alpha.ind = 1, geom = c("point"), xlim = c(-5, 5),  axes = c(1, 3),  palette = viridis(3, begin = 0.3), geom.var = c("arrow", "text"))
     plot_pca_13 <- fviz_add(plot_pca_13, quanti.coord, axes = c(1, 3), "arrow", color = "black", linetype = "solid", repel = T, addlabel = T)
     res = list(PCA = pca_stand, plot12 = plot_pca_12, plot13 = plot_pca_13, criteria = keep_criteria)
     } else {
 res = list(PCA = pca_stand, plot12 = plot_pca_12, criteria = keep_criteria)
     }
   return(res)
}


run_group_pca2 = function(cwm, traits, trait_direction, direction = '>0', plot = TRUE, env_corr, Labels = NA, annot = NA, naxes = 2){
  
  data = data.frame(cwm[, .SD, .SDcols = c('LUI', 'Disturbance', 'Fertilisation', traits)])
    rownames(data) = cwm$Plot
data = data[complete.cases(data),]
  pca_stand = PCA(data, graph=FALSE, quanti.sup = 1:3)
   
     # Store the direction of the expected fast_slow axis (1 is left to right, -1 is right to left)
 direction_axis = numeric()
  for (i in 1:length(direction)){
   if (pca_stand$var$coord[trait_direction[i], i] > 0 & direction[i]  == '>0' |
       pca_stand$var$coord[trait_direction[i], i] < 0 & direction[i]  == '<0'){
    direction_axis = c(direction_axis, 1)
  } else {
    direction_axis = c(direction_axis,-1)
      }
  }
 
     # Change direction
 pca_to_plot = pca_stand
 pca_to_plot$var$coord = pca_to_plot$var$coord*direction_axis
 pca_to_plot$ind$coord = pca_to_plot$ind$coord*direction_axis
 pca_to_plot$quanti.sup$coord = pca_to_plot$quanti.sup$coord*direction_axis

    naxes = length(traits)
   
    corr_unsignificant = 0
    for (trait in traits){
     cor = cor.test(unlist(data[, trait]), pca_stand$ind$coord[,1])
    if (cor$p.value > 0.05){
      corr_unsignificant = corr_unsignificant+1
    }
   }
   
   keep_criteria = data.table('More_than_random' = pca_stand$eig[1] / (1/length(traits)),
                              'Prop.traits.40' =   length(pca_stand$var$cor[,1][abs(pca_stand$var$cor[,1])>0.4])/length(pca_stand$var$cor[,1]),
                              'Prop.traits.25' =   length(pca_stand$var$cor[,1][abs(pca_stand$var$cor[,1])>0.25])/length(pca_stand$var$cor[,1]),
                              'Cor_unsignificant' =  corr_unsignificant)
   keep_criteria[, enough_support := More_than_random >2 & Prop.traits.40 >= 0.60]
   keep_criteria[, partial := More_than_random >2 & Prop.traits.25 >= 0.60 & Cor_unsignificant <= 1]
   keep_criteria[, LUI.Axis1 := round(cor.test(data$LUI, pca_stand$ind$coord[,1])$p.value, 3)]
   keep_criteria[, LUI.Axis2 := round(cor.test(data$LUI, pca_stand$ind$coord[,1])$p.value, 3)]


  names(Labels)  = traits

if (is.na(annot)){
  Criteria_label = ifelse(keep_criteria$enough_support, 'Criteria met', 'Criteria not met!')
  if (keep_criteria$partial == TRUE & keep_criteria$enough_support != TRUE){
    Criteria_label = paste('Criteria partially met', sep = ' ')
  }
  
  Criteria_label = paste(Criteria_label, '\n Axis1 x LUI: p =', keep_criteria$LUI.Axis1,
                         '\n Axis2 x LUI: p =', keep_criteria$LUI.Axis2, sep = '')
}else{
  Criteria_label =  annot
}

rownames(pca_to_plot$var$coord) = rownames(pca_to_plot$var$cor) = rownames(pca_to_plot$var$cos2) = Labels

if (env_corr == TRUE){
  plot_pca_12 = fviz_pca(pca_to_plot, title = '', geom = 'point', geom.var = c("arrow", 'text'), col.quanti.sup = 'darkred', col.var = 'grey30', 
                       labelsize = 3, repel = T)
}
if (env_corr == FALSE){
  plot_pca_12 = fviz_pca(pca_to_plot, title = '', geom = 'point', geom.var = c("arrow", 'text'), col.quanti.sup = 'darkred', col.var = 'grey30', habillage = factor(substr(rownames(pca_to_plot$ind$coord), 1, 1)), 
                       labelsize = 3, repel = T) +
  scale_shape_discrete( breaks = c('A', 'H', 'S'), labels = c('South', 'Central', 'North'), name = 'Region')+
  scale_color_viridis(discrete = TRUE, begin = 0.3, breaks = c('A', 'H', 'S'), labels = c('South', 'Central', 'North'), name = 'Region')

}

  res = list(PCA = pca_stand, plot12 = plot_pca_12, criteria = keep_criteria, direction = direction_axis)
  
  return(res)
}
```

### Plants, above- and below-ground

```{r, echo = FALSE, warning=FALSE, eval = T,fig.show="hold", out.width="50%"}
### With all traits
#print_table(Hypothesis_table[Group %in% 'plants',])
library(viridisLite)

print('Plants, All')

all_plant_traits = c("plants_LDMC" , "plants_LeafN", "plants_LeafP", "plants_Seed_mass", "plants_SLA_all" , "plants_Root_tissue_density")
labels_plants =  c("LDMC"     , 
                     "Leaf N"  , 
                      "Leaf P" , 
                     "Seed mass" ,
                     "SLA",
                   'Root tissue density')
pca_plants_all = run_group_pca2(env_corr = env_corr, all_cwm_not_imputed, all_plant_traits ,Labels =labels_plants, 'plants_SLA_all')
pca_plants_all$plot12
pca_plants_all$criteria

ggsave(plot = pca_plants_all$plot12,file = paste('Results/NOSIZE/Plant_com_pca.pdf', sep = ''), width = 6, height = 6)

```

## Bacteria & fungi

```{r eval=T, echo=FALSE, fig.show="hold", message=FALSE, warning=FALSE, out.width="50%"}
#print_table(Hypothesis_table[Group %in% c('bact_fungi'),])
traits_Bact_fungi = c(#"bact_fungi_logVolume"   ,
  "bact_fungi_Genome_size"  , 
                  "bact_fungi_OC_ratio" , "bact_fungi_FB_ratio" ,"bact_fungi_pathogens"
                  )
labels_Bact_fungi =  c(#"Cell volume (bacteria)"     , 
                     "Genome size (bacteria)"  , 
                      "Oligotrophic:copiotrophic ratio (bacteria)" , 
                     "Fungi:bacteria ratio" ,
                     "Proportion plant pathogen (fungi)"
                  )
pca_mic = run_group_pca2(env_corr = env_corr, all_cwm_not_imputed, traits_Bact_fungi, 'bact_fungi_pathogens',  Labels = labels_Bact_fungi)
pca_mic$plot12
pca_mic$criteria

ggsave(plot = pca_mic$plot12, file = paste('Results/NOSIZE/bact_fungi_OCm_pca.pdf', sep = ''), width = 6, height = 6)
```

## Arthropods, above-ground
### Herbivores

```{r, echo = FALSE, warning=FALSE, eval = T,fig.show="hold", out.width="50%"}
#print_table(Hypothesis_table[grepl('Arthropods', Group),])

traits_Arthropods_above_herb = c("arthropods_above_herb_Dispersal_ability", #"arthropods_above_herb_logBody_Size" , 
                                 "arthropods_above_herb_Feeding_generalism",    "arthropods_above_herb_Generations")
labels_arthro_herb =  c("Dispersal"     , 
                      #  "Body size" ,
                        "Generalism"  , 
                        "Gen. per year" 
                  )
pca_arthro_herb = run_group_pca2(env_corr = env_corr, all_cwm_not_imputed, traits_Arthropods_above_herb, 'arthropods_above_herb_Dispersal_ability', Labels = labels_arthro_herb)
pca_arthro_herb$plot12
ggsave(plot = pca_arthro_herb$plot12, file = paste('Results/NOSIZE/Arthro_herb_AG_com_pca.pdf', sep = ''), width = 6, height = 6)


traits_Arthropods_below_herb = c("arthropods_below_herb_Dispersal_ability", #"arthropods_below_herb_logBody_Size" , 
                                 "arthropods_below_herb_Feeding_generalism")

labels_arthro_below_herb =  c("Dispersal"     , 
                          # "Body size" ,
                           'Generalism'
                  )
pca_arthro_herb_below = run_group_pca2(env_corr = env_corr, all_cwm_not_imputed, traits_Arthropods_below_herb, 'arthropods_below_herb_Dispersal_ability', Labels = labels_arthro_below_herb)

pca_arthro_herb_below$plot12  = pca_arthro_herb_below$plot12 + ylim(c(-5, 4))
pca_arthro_herb_below$criteria
  
ggsave(plot = pca_arthro_herb_below$plot12,file =
         paste('Results/NOSIZE/Arthro_herb_BG_com_pca.pdf', sep = ''), width = 6, height = 6)

traits_Butterflies = c("butterflies_Generalism_use",
                       #"butterflies_logSize",     
                       "butterflies_Voltinism_use",
                       "butterflies_Wintering_stage",
                       "butterflies_logFlight")
labels_but =  c("Generalism", 
               # "Size" ,
                "Voltinism" ,
                "Hibernation stage", 
                "Flight period"  
                  )

pca_but = run_group_pca2(env_corr = env_corr, all_cwm_not_imputed, Labels = labels_but, traits_Butterflies, 'butterflies_logFlight')
pca_but$plot12
pca_but$criteria

#print_table(Hypothesis_table[Group  %in% c('Arthropods (herbivores)', 'Butterflies'),])

ggsave(plot = pca_but$plot12, file = paste('Results/NOSIZE/Butterflies_com_pca.pdf', sep = ''), width = 6, height = 6)
```

### Predators

```{r, echo = FALSE, warning=FALSE, eval = T,fig.show="hold", out.width="50%"}
#print_table(Hypothesis_table[grepl('Arthro',Group) & !grepl('herbi', Group),])
traits_Arthropods_above_omni_carni = c('arthropods_above_carni_Dispersal_ability'#, 'arthropods_above_carni_logBody_Size'
                                       )

#labels_arthro_omni_carni = c('Dispersal', 'Body size')
#pca_arthro_pred = run_group_pca2(env_corr = env_corr, all_cwm_not_imputed, traits_Arthropods_above_omni_carni, #c('arthropods_above_carni_Dispersal_ability', 'arthropods_above_carni_Dispersal_ability'), direction = c('>0','>0'), Labels = #labels_arthro_omni_carni)
#pca_arthro_pred$plot12
#
#ggsave(plot = pca_arthro_pred$plot12, file = paste('Results/NOSIZE/Arthro_oc_com_pca.pdf', sep = ''), width = 6, height = 6)


traits_Arthropods_below_omni_carni = c('arthropods_below_omni_carni_Dispersal_ability' #,'arthropods_below_omni_carni_logBody_Size'
)
labels_arthro_below_omni_carni = c('Dispersal', 'Body size')

#pca_arthro_pred_below = run_group_pca2(env_corr = env_corr, all_cwm_not_imputed, traits_Arthropods_below_omni_carni, #'arthropods_below_omni_carni_Dispersal_ability', Labels = c('Dispersal', 'Body size'))
#pca_arthro_pred_below$plot12
#
#ggsave(plot = pca_arthro_pred_below$plot12,file =
#         paste('Results/NOSIZE/Arthro_oc_BG_com_pca.pdf', sep = ''), width = 6, height = 6)
```


## Birds

```{r, echo = FALSE, warning=FALSE, eval = T,fig.show="hold", out.width="50%"}

  #print_table(Hypothesis_table[grepl('Birds', Group),])
traits_Birds_insect = c(#"birds_logBody_Mass",   
  "birds_logIncub_time"    ,   "birds_logBrood",      "birds_GenLength" ) 
birds_labels = c(#'Body mass',
'Incubation time', 'Offspring max',  'Generation time')
pca_birds_all= run_group_pca2(env_corr = env_corr, all_cwm_not_imputed, traits_Birds_insect, 'birds_logBrood', Labels = birds_labels)
pca_birds_all$plot12
pca_birds_all$criteria


ggsave(plot = pca_birds_all$plot12,file =  paste('Results/NOSIZE/Birds_i_com_pca.pdf', sep = ''), width = 6, height = 6)


```

## Mites & collembola

```{r, echo = FALSE, warning=FALSE, eval = T,fig.show="hold", out.width="50%"}
#print_table(Hypothesis_table[grepl('Mites', Group),])

traits_Mites_all = c( "mites_Habitat_spec",  "mites_Repro_sex" , # "mites_logMass"   ,
                      "mites_Feeding_spec","mites_DaystoAdult"     )
mites_labels = c('Habitat specialisation', 'Sexual repro',# 'Body mass', 
                 'Feeding specialisation', 'Days to adult')
pca_mites_all = run_group_pca2(env_corr = env_corr, all_cwm_not_imputed, traits_Mites_all, 'mites_DaystoAdult', direction = '<0', Labels = mites_labels)
pca_mites_all$plot12
pca_mites_all$plot13
pca_mites_all$criteria

ggsave(plot = pca_mites_all$plot12,file = 
         paste('Results/NOSIZE/Mites_com_pca.pdf', sep = ''), width = 6, height = 6)
```

```{r, echo = FALSE, warning=FALSE, eval = T,fig.show="hold", out.width="50%"}
#print_table(Hypothesis_table[grepl('Coll', Group),])
traits_Coll_all = c(  #"coll_logSize",  
  "coll_Depth_preference", "coll_Gen_per_year"   ,    "coll_Repro_sex" )
col_labels = c(#'Body size', 
'Depth preference', 'Generations per year', 'Sexual reproduction')
pca_coll_all = run_group_pca2(env_corr = env_corr, all_cwm_not_imputed, traits_Coll_all, 'coll_Depth_preference',  Labels = col_labels)
pca_coll_all$plot12
pca_coll_all$plot13
pca_coll_all$criteria

ggsave(plot = pca_coll_all$plot12, file = paste('Results/NOSIZE/Coll_com_pca.pdf', sep = ''), width = 6, height = 6)

```

## Bats

```{r, echo = FALSE, warning=FALSE, eval = T,fig.show="hold", out.width="50%"}
#print_table(Hypothesis_table[grepl('Bats', Group),])

traits_Bats =c(#"bats_logBody_mass" ,   
  "bats_Lifespan"   ,      "bats_Number_offspring")
bats_labels = c(#'Body mass',
'Lifespan', 'Offspring')
pca_bats_all = run_group_pca2(env_corr = env_corr, all_cwm_not_imputed, traits_Bats, 'bats_Number_offspring', Labels = bats_labels)
pca_bats_all$plot12
pca_bats_all$plot13
pca_bats_all$criteria

ggsave(plot = pca_bats_all$plot12,file = paste('Results/NOSIZE/Bats_com_pca.pdf', sep = ''), width = 6, height = 6)
```

```{r, echo = FALSE, warning=FALSE, eval = T,fig.show="hold", out.width="50%"}
#big_pca
cwm_cast = dcast(all_cwm_lui[traitName2 %in% Hypothesis_table$Trait_short], Plot ~ traitName2, value.var =  'value')
cwm_cast$birds_GenLength = log(cwm_cast$birds_GenLength )
# Weight traits by 1/n traits in the group to give same weight to all groups
weight.data = all_cwm_lui[traitName2 %in% Hypothesis_table$Trait_short, list(trait = unique(traitName2), weight = 1/length(unique(traitName2))), by = Group]
weights = weight.data$weight; names(weights) = weight.data$trait
pca_all = PCA(cwm_cast[,-1], col.w = weights[colnames(cwm_cast[,-1])])
slow_fast_expecations = Hypothesis_table$Expected_direction
names(slow_fast_expecations) = Hypothesis_table$Trait_short
fviz_pca(pca_all, col.var = slow_fast_expecations[colnames(cwm_cast)[-1]], palette = c(  '#3e4989', '#35b779'))

ggsave(plot = pca_bats_all$plot12,file = paste('Results/NOSIZE/Bats_com_pca.pdf', sep = ''), width = 6, height = 6)
```

# Assemble data

```{r, echo = FALSE, warning=FALSE, eval = T,fig.show="hold", out.width="80%"}
autowrite_SEM_full = function(model_raw, trophic_levels = Trophic_levels, LUI = T, Data = dd){
  # This function takes a model formula without parameters
  # and creates all the parameter names for direct, indirect and total effects
  model_init <- sem(model_raw,
                    data = Data)
  coefficients = data.table(parameterEstimates(model_init, standardized = T))
  coefficients = coefficients[lhs != rhs,]
  coefficients = coefficients[op == '~',]
  
  coefficients_lm = coefficients[op == '~',]
  exo_var = unique(coefficients_lm$rhs[!(coefficients_lm$rhs %in% coefficients_lm$lhs)])
  
  effect_list = list()
  model_lines = list()

  for (group in unique(coefficients$lhs)){
    # Write down main model line
    RHS = coefficients[lhs == group, ]
    right_hand = paste(paste(RHS$rhs, RHS$lhs, sep = '__'), '*', RHS$rhs, collapse = ' + ', sep = '')
    lm_line = paste(group, '~', right_hand)
    model_lines = append(model_lines, lm_line)
    
    for (exo in exo_var){
    # Direct effect
    direct = paste('Direct__', exo, '__', group, '__', trophic_levels[group], sep = '')
    
    direct_rhs = paste(' := ', exo, '__', group, sep = '')
    direct_line = paste(direct, direct_rhs , sep = '')
    model_lines = append(model_lines, direct_line)
    effect_list = append(effect_list, direct)
    
    # Indirect effect
    RHS_indirect = RHS[!(rhs %in% exo_var),]
    if (nrow(RHS_indirect) > 0){
      indirect = paste('Indirect__', exo, '__', group, '__', trophic_levels[group], sep = '')
      indirect_rhs = paste( 
        paste('Total__', exo, '__', RHS_indirect[, rhs], '__', trophic_levels[RHS_indirect[, rhs]], sep = ''), 
        '*',
        paste(RHS_indirect[, rhs], '__', group, sep = ''), sep = '', collapse = ' + ')
      indirect_line = paste( indirect , indirect_rhs, sep = ' := ')
      model_lines = append(model_lines, indirect_line)
      effect_list = append(effect_list, indirect)
      
      # Total effect
      total = paste('Total__', exo, '__', group, '__', trophic_levels[group], sep = '')

      total_rhs = paste(direct, indirect, sep = ' + ')
      total_line = paste(total, total_rhs, sep = ' := ')
  
      model_lines = append(model_lines, total_line)
      effect_list = append(effect_list, total)
       
      
    }
    else {
      total = paste('Total__', exo, '__', group, '__', trophic_levels[group], sep = '')
      total_line = paste(total, direct, sep = ' := ')
      model_lines = append(model_lines, total_line)
      effect_list = append(effect_list, total)
      
    }
  }
  }
  
  effect_list = unlist(effect_list)
  overall_effects = list()
  for (trophic_lvl in unique(trophic_levels[coefficients$lhs])){
    for (type in c('Direct', 'Indirect', 'Total')){
          print(type)
      if (!(type == 'Indirect' & trophic_lvl == 0)){
      for (exo in exo_var){
      effect = paste(type, exo, trophic_lvl, sep = '__')
      relevant_effects = effect_list[grepl(type, effect_list) & grepl(trophic_lvl, effect_list) & grepl(exo, effect_list)]
      rhs = paste('(', 
                  paste(relevant_effects, collapse = ' + '),
                  ')/', length(relevant_effects))
      overall_effects = append(overall_effects, paste(effect, rhs, sep = ':='))
    }
   }}
  }
  whole_model = paste(c(unlist(model_lines), unlist(overall_effects)), collapse = ' \n ')
  return(whole_model)
}
```

```{r, echo = FALSE, warning=FALSE, eval = T,fig.show="hold", out.width="80%"}

#### Check the criteria
#criterias = rbind(pca_plants_all$criteria[, Group := 'plants'],
#           pca_arthro_herb$criteria[, Group := 'arthro_herb'],
#           pca_arthro_herb_below$criteria[, Group := 'arthro_herb_below'],
#          # pca_arthro_pred$criteria[, Group := 'arthro_pred'],
#           #pca_arthro_pred_below$criteria[, Group := 'arthro_pred_below'],
#           pca_mic$criteria[, Group := 'mic'],
#           pca_mites_all$criteria[, Group := 'mites'],
#           pca_coll_all$criteria[, Group := 'coll'],
#           pca_but$criteria[, Group := 'butterflies'],
#           pca_birds_all$criteria[, Group := 'birds'],
#           pca_bats_all$criteria[, Group := 'bats'])
#
#print(criterias)

#### Put all the PCA axes together to compare correlations to LUI. 
#sfx <- c("__Plants_primary_producers", "__Arthropods_primary_consumers_aboveground", '__Arthropods_primary_consumers_belowground', #"__Arthropods_secondary_consumers_aboveground", '__Arthropods_secondary_consumers_belowground','__Bacteria_and_fungi', #'__Protists_primary_consumers','__Protists_bacterivores', '__Protists_secondary_consumers',  '__Oribatid_mites_omnivores_belowgroud', #'__Collembola_omnivores_belowground', '__Lepidoptera_primary_consumers', '__Birds_tertiary_consumers', '__Bats_tertiary_consumers')
#list.df = list(  # Getting all the axes and multiplying the slow-fast axis by -1 if needed so that increasing axis values means faster system
#        data.table(  pca_plants_all$PCA$ind$coord[, 1:2], keep.rownames = TRUE)[, Map("*", .SD, c(pca_plants_all$direction, 1, 1)),  by= rn],
#        data.table(  pca_arthro_herb$PCA$ind$coord[, 1:2], keep.rownames = TRUE)[, Map("*", .SD, c(pca_arthro_herb$direction, 1, 1)),  by= rn],
#        data.table(  pca_arthro_herb_below$PCA$ind$coord[, 1:2], keep.rownames = TRUE)[, Map("*", .SD, c(pca_arthro_herb_below$direction, 1, 1)),  by= rn],
#        data.table(  data.table( Dim.1 = all_cwm$arthropods_above_carni_Dispersal_ability, rn =all_cwm$Plot)),
#                     #pca_arthro_pred$PCA$ind$coord[, 1:2], keep.rownames = TRUE)[, Map("*", .SD, c(pca_arthro_pred$direction)),  by= rn],
#        data.table(  data.table( Dim.1 = all_cwm$arthropods_below_omni_carni_Dispersal_ability, rn =all_cwm$Plot)),
#                     #pca_arthro_pred_below$PCA$ind$coord[, 1:2], keep.rownames = TRUE)[, Map("*", .SD, c(pca_arthro_pred_below$direction, 1)),  by= rn],
#        data.table(  pca_mic$PCA$ind$coord[, 1:2], keep.rownames = TRUE)[, Map("*", .SD, c(pca_mic$direction, 1, 1)),  by= rn],
#        data.table(  Dim.1 = all_cwm$protists_nutrition_code_primary_cons, rn =all_cwm$Plot),
#        data.table(  pca_mites_all$PCA$ind$coord[, 1:2], keep.rownames = TRUE)[, Map("*", .SD, c(pca_mites_all$direction, 1, 1)),  by= rn],
#        data.table(  pca_coll_all$PCA$ind$coord[, 1:2], keep.rownames = TRUE)[, Map("*", .SD, c(pca_coll_all$direction, 1, 1)),  by= rn],
#        data.table(  pca_but$PCA$ind$coord[, 1:2], keep.rownames = TRUE)[, Map("*", .SD, c(pca_but$direction, 1, 1)),  by= rn],
#        data.table(  pca_birds_all$PCA$ind$coord[, 1:2], keep.rownames = TRUE)[, Map("*", .SD, c(pca_birds_all$direction, 1, 1)),  by= rn],
#        data.table(  pca_bats_all$PCA$ind$coord[, 1:2], keep.rownames = TRUE)[, Map("*", .SD, c(pca_bats_all$direction, 1, 1)),  by= rn])
#res <- list.df[[1]]
#for(i in head(seq_along(list.df), -1)) {
# res <- merge.data.table(res, list.df[[i+1]], all = TRUE, suffixes = sfx[i:(i+1)], by = c("rn"))
#  }
#
#all_axes = merge(res[, Plot:=rn],
#                 env_data_lui[,.SD, .SDcols = c('LUI','Plot')],
#                 by = 'Plot')
#
### Check correlation of all axes, incl correction for multiple testing
#axis_LUI_correlation_table = merge(
#data.table(round(cor(all_axes[, .SD, .SD = colnames(all_axes)[-c(1,2)]], use = 'pairwise.complete.ob'),2),keep.rownames = T)[, list(Axis = rn, corr = LUI)],
#data.table(cor_pmat(all_axes[, .SD, .SD = colnames(all_axes)[-c(1,2)]], use = 'pairwise.complete.ob'), keep.rownames = T)[, list(Axis = rn, pval = LUI)])
#axis_LUI_correlation_table[Axis %in% c('Dim.1', 'Dim.2', "Dim.3"), Axis := paste(Axis, 'Bats_tertiary_consumers', sep = '__')]
#axis_LUI_correlation_table = axis_LUI_correlation_table[Axis != 'LUI',]
#axis_LUI_correlation_table[, padj := p.adjust(pval, 'fdr')]
#axis_LUI_correlation_table[, c('Axis', 'Group') := tstrsplit( Axis, '__')]
#axis_LUI_correlation_table[Axis == 'V1', Axis := 'Axis1']
#axis_LUI_correlation_table[, Group  := gsub('_', ' ', Group)]
#axis_LUI_correlation_table[, p_symbol := ifelse(padj < 0.001, "***", 
#                                                ifelse(padj < 0.01, "**",
#                                                    ifelse(padj < 0.05, "*", 'n.s.')))]
#axis_LUI_correlation_table[, label := paste(corr, p_symbol, sep = ' ')]
#gg_correlation_axes = ggplot(axis_LUI_correlation_table, aes( x = Axis, fill = corr, y = factor(Group, levels =  c(
#  "Arthropods secondary consumers belowground",                 
#  "Arthropods primary consumers belowground",
#  "Collembola omnivores belowground",
#  "Oribatid mites omnivores belowgroud",
#  "Protists secondary consumers",
#  "Protists bacterivores",
#  "Protists primary consumers",
#  "Bacteria and fungi",
#  "Plants primary producers" ,  
#  "Lepidoptera primary consumers", 
#  "Arthropods primary consumers aboveground",
#  "Arthropods secondary consumers aboveground",
#  "Birds tertiary consumers", 
#  "Bats tertiary consumers" )))) + geom_tile(color = "white",
#            lwd = 1.5,
#            linetype = 1)+
#  theme_bw() +
#  geom_text(aes(label = label), color = "black", size = 4) +
#   scale_fill_gradient2(low = '#d73027', high = '#1a9850', mid = '#ffffbf', name = 'Correlation with LUI') +
#  ylab('Trophic guild') + xlab('PCA axis')
#
#ggsave(plot = gg_correlation_axes ,file = paste('Results/NOSIZE/gg_correlation_axes.pdf', sep = ''), width = 8, height = 8)




### Now subset it to only fast-slow axes, multiplied by direction so that the axis goes from slow to fast
# Check how much vriance is explained
#prop = c( plant = pca_plants_all$PCA$eig[,2][ 1],
#        Arth_herb = pca_arthro_herb$PCA$eig[,2][ifelse(weight == TRUE, 1, 2)], # When the data is not weighted by abundance, the fast-slow axis of herbivorous #arthropods above-ground is on PC2
#        (Arth_herb_below = pca_arthro_herb_below$PCA$eig[,2][1]),
#        (Arth_omnicarni= pca_arthro_pred$PCA$eig[,2][2]),
#        (Arth_omnicarni_below = pca_arthro_pred_below$PCA$eig[,2][ 1]),
#        (Bact_fungi = pca_mic$PCA$eig[,2][ 1]),
#        (Mites = pca_mites_all$PCA$eig[,2][ 1]),
#        (Coll = pca_coll_all$PCA$eig[,2][ 1]),
#        (But  = pca_but$PCA$eig[,2][1]),
#        (BirdsI  = pca_birds_all$PCA$eig[,2][ 1]),
#        (Bats = pca_bats_all$PCA$eig[,2][ 1]))
#mean(prop)
#sd(prop)
## When the data is not weighted by abundance, the fast-slow axis of herbivorous arthropods above-ground is on PC2
dd = Reduce(function(...) merge(..., all = TRUE, by = 'Plot'), 
  list( data.table(plant = pca_plants_all$PCA$ind$coord[, 1]*pca_plants_all$direction,
                   Plot  = rownames(pca_plants_all$PCA$ind$coord)),
        data.table(Arth_herb = pca_arthro_herb$PCA$ind$coord[, ifelse(weight == TRUE, 1, 2)]*pca_arthro_herb$direction, # When the data is not weighted by abundance, the fast-slow axis of herbivorous arthropods above-ground is on PC2

                   Plot = rownames(pca_arthro_herb$PCA$ind$coord)),
        data.table(Arth_herb_below = pca_arthro_herb_below$PCA$ind$coord[, 1]*pca_arthro_herb_below$direction , 
                   Plot = rownames(pca_arthro_herb_below$PCA$ind$coord)),
        data.table(Arth_omnicarni= all_cwm$arthropods_above_carni_Dispersal_ability, 
                   Plot = all_cwm$Plot),
        data.table(Arth_omnicarni_below = all_cwm$arthropods_below_omni_carni_Dispersal_ability, 
                   Plot = all_cwm$Plot),
        data.table(Bact_fungi = pca_mic$PCA$ind$coord[, 1]*pca_mic$direction, 
                   Plot = rownames(pca_mic$PCA$ind$coord)),
        data.table(Protists_patho =  all_cwm$protists_nutrition_code_primary_cons,    
                   Plot =  all_cwm$Plot),
        #data.table(Mites = pca_mites_all$PCA$ind$coord[, 1]*pca_mites_all$direction, 
       #            Plot = rownames(pca_mites_all$PCA$ind$coord)),
        data.table(Coll = pca_coll_all$PCA$ind$coord[, 1]*pca_coll_all$direction, 
                   Plot = rownames(pca_coll_all$PCA$ind$coord)),
        data.table(But  = pca_but$PCA$ind$coord[, 1]*pca_but$direction, 
                   Plot = rownames(pca_but$PCA$ind$coord)),
        data.table(BirdsI  = pca_birds_all$PCA$ind$coord[, 1]*pca_birds_all$direction, 
                   Plot = rownames(pca_birds_all$PCA$ind$coord)),
        data.table(Bats = pca_bats_all$PCA$ind$coord[, 1]*pca_bats_all$direction, 
                   Plot = rownames( pca_bats_all$PCA$ind$coord)),
        env_data_lui[,.SD, .SDcols = c('LUI', 'LII', 'Fertil', 'Mowing', 'Grazing', "Disturbance", "Fertilisation",'Plot')]))


all_col = colnames(dd)[-1]

dd[, (all_col) := lapply(.SD, function(x){as.numeric(scale(x))}), .SDcols = all_col]
  
# Then we mice it
dd_miced =   mice::complete(mice(dd[,  c('LUI', "Disturbance", "Fertilisation", "plant", "Arth_herb", "Arth_herb_below",
                           "Arth_omnicarni", 
                           "Arth_omnicarni_below","Bact_fungi",  "Protists_patho", # "Mites", 
                           "Coll", "But",   "BirdsI",  "Bats")], printFlag = FALSE, method = 'mean'))

PCA_pca_LUI = PCA(dd_miced[,  c('LUI', "plant", "Arth_herb",
                           "Arth_omnicarni", 
                           "Arth_omnicarni_below","Bact_fungi",  "Protists_patho",  # "Mites", 
                           "Coll", "But",   "BirdsI",  "Bats")], quanti.sup = 1)

PCA_pca= PCA(dd_miced[,  c('LUI', "Disturbance", "Fertilisation", "plant", "Arth_herb",
                           "Arth_omnicarni", 
                           "Arth_omnicarni_below","Bact_fungi",  "Protists_patho",  # "Mites",
                           "Coll", "But",   "BirdsI",  "Bats")], quanti.sup = 1:3)

if (env_corr == FALSE){
pca_pca_plot = fviz_pca(PCA_pca, geom =c("point"),geom.var = c('arrow', 'text'), col.quanti.sup = 'darkred', col.var = 'grey30',
                       habillage = factor(substr(env_data_lui[Plot %in% dd$Plot,Plot], 1, 1)),
                        palette = viridis(3, begin = 0.3), repel = TRUE)
pca_pca_plot_nolabel = fviz_pca(PCA_pca, geom =c("point"),geom.var = c('arrow'), col.quanti.sup = 'darkred', col.var = 'grey30',
                      habillage = factor(substr(env_data_lui[Plot %in% dd$Plot,Plot], 1, 1)), palette = viridis(3, begin = 0.3), repel = TRUE)

pca_pca_plot_LUI = fviz_pca(PCA_pca_LUI, geom =c("point"),geom.var = c('arrow'), col.quanti.sup = 'darkred', col.var = 'grey30',
                       habillage = factor(substr(env_data_lui[Plot %in% dd$Plot,Plot], 1, 1)),
                       palette = viridis(3, begin = 0.3), repel = TRUE)}
if (env_corr == TRUE){
pca_pca_plot = fviz_pca(PCA_pca, geom =c("point"),geom.var = c('arrow', 'text'), col.quanti.sup = 'darkred', col.var = 'grey30',
                        repel = TRUE)
pca_pca_plot_nolabel = fviz_pca(PCA_pca, geom =c("point"),geom.var = c('arrow'), col.quanti.sup = 'darkred', col.var = 'grey30',
                      repel = TRUE)

pca_pca_plot_LUI = fviz_pca(PCA_pca_LUI, geom =c("point"),geom.var = c('arrow'), col.quanti.sup = 'darkred', col.var = 'grey30',
                       repel = TRUE)}

ggsave(plot = pca_pca_plot ,file = paste('Results/NOSIZE/All_groups_pca.pdf', sep = ''), width = 8, height = 6)

ggsave(plot = pca_pca_plot_LUI, file = paste('Results/NOSIZE/All_groups_pca_LUI_nolabel.pdf', sep = ''), width = 8, height = 6)

ggsave(plot = pca_pca_plot_nolabel, file = paste('Results/NOSIZE/All_groups_pca_nolabel.pdf', sep = ''), width = 8, height = 6)

# Test correlation between PCA axis 1 and LUI
cor.test(PCA_pca$ind$coord[, 1], env_data_lui[Plot %in% dd$Plot,]$LUI)


Trophic_levels = list( "plant" = 0, 
                       "Arth_herb" = 1,
                    #   "Arth_herb_below" = 2,
                       "But"  = 1,  
                       "Arth_omnicarni" = 2,
                       "Arth_omnicarni_below" = 3,
                       "Bact_fungi"  = 1,  
                       "Protists_patho"  = 1,  
                      # "Protists_bact"  = 2, 
                     #  "Protists_sec" = 2,  
                      # "Mites"  = 2, 
                       "Coll"  = 2, 
                       "BirdsI"  = 3,  
                       "Bats"  = 3
                      )

```

# Try SEM
## Run above-ground model, simple

```{r, eval = FALSE, echo = FALSE, warning=FALSE, eval = T,fig.show="hold", out.width="80%"}
mod_AG =  "
        plant ~ LUI 
        
        Arth_herb ~ LUI  + plant   
        But       ~ LUI  + plant  

        Arth_omnicarni ~ LUI + plant + But + Arth_herb
        BirdsI ~ LUI + plant + But + Arth_herb + Arth_omnicarni
        Bats ~   LUI + plant + But + Arth_herb + Arth_omnicarni
      
        Bats ~~ BirdsI
"
 model_init_AG <- sem(mod_AG,
    data = dd
)

 model_AG = sem(paste(autowrite_SEM_full(model_init_AG, Trophic_levels), 'Bats ~~ BirdsI', sep = '\n'),
                dd,
                estimator = "ML",
                missing = "ML",
                se = 'bootstrap', bootstrap = 300
                )
 
 semtable_AG <- semTable (model_AG, fits = c('pvalue', 'rmsea', 'cfi', 'bic'), print.results = FALSE, type = 'csv', paste('Results/NOSIZE/SEM_table_AG.csv', sep = ''))
 
 fitmeasures(model_AG, c("cfi", "rmsea", "rmsea.ci.upper", "bic"))
 
 layout_AG <- matrix(c(
# Pl1      aherb     but     Arth_omni       BirdsI    bats    LUI
c(4,          5,       3,      3,              3,      5,       -2),
c(0,          1.5,    1.5,     3,              4.5,   4.5,      0 )), ncol = 2)
 p =  semPaths(model_AG,  what = "std", whatLabels = 'no', #layout = layout_AG, 
               residuals = F, edge.label.cex = 0, borders = F, vTrans = 0,
               node.width = 1)
  p_theo =  semPaths(model_init_AG,   whatLabels = 'no', layout = layout_AG, 
               residuals = F, edge.label.cex = 0, borders = F, vTrans = 0,
               node.width = 1)

 pdf(file = paste('Results/NOSIZE/SEM_AG.pdf', sep = ''), width = 5)
 plot(p)
 dev.off()
```


## Run below-ground model, simple

```{r, eval = FALSE, echo = FALSE, warning=FALSE, eval = T,fig.show="hold", out.width="80%"}
mod_BG_0 =  "
        plant ~ LUI 
        
        Protists_patho  ~ LUI + plant
        Bact_fungi   ~      LUI + plant
        
       
        Coll   ~          LUI + Bact_fungi + plant  + Protists_patho

        Arth_omnicarni_below ~ LUI  + Coll + plant + Protists_patho  
 
"
 model_BG_raw <- sem(mod_BG_0,
    data = dd)
# View(data.table(modificationindices(model_BG_raw))[order(mi, decreasing = T), ])
 summary(model_BG_raw, standardized = TRUE)

# Remove non-significant with standardised effects < 0.05
mod_BG =  "
        plant ~ LUI 
        
        Protists_patho  ~ LUI + plant
        Bact_fungi   ~      LUI + plant
        
       
        Coll   ~          LUI + plant + Bact_fungi 

        Arth_omnicarni_below ~ LUI  + Coll 

"
 model_BG_init <- sem(mod_BG,
    data = dd)
  summary(model_BG_init, standardized = TRUE)

#View(data.table(modificationindices(model_BG_init))[order(mi, decreasing = T), ])
fitmeasures(model_BG_init, c("cfi", "rmsea", "rmsea.ci.upper", "bic"))

model_BG = sem(paste(autowrite_SEM_full(model_BG_init, Trophic_levels), 'Protists_patho ~~ Bact_fungi \n Protists_patho ~~ 0*Arth_omnicarni_below', sep = '\n'),
                dd,  
                estimator = "ML",
                missing = "ML",
                se = 'bootstrap', bootstrap = 100
               )
 
 semtable_BG <- semTable (model_BG, fits = c('pvalue', 'rmsea', 'cfi', 'bic'), print.results = FALSE, type = 'csv',paste('Results/NOSIZE/SEM_table_BG.csv', sep = ''))
 
 fitmeasures(model_BG, c("cfi", "rmsea", "rmsea.ci.upper", "bic"))

 ly2 <- matrix(c(
# Pl1   Mic  Pro1    Mites ,   Prob;    Pro2    Coll  , Arth_herb_below, Arth_carni  LUI
c(4,    3.5,  4.5,   5.5,     3.5,      2.5,     4.5,      4,    -2),
c(0, -1.5,  -1.5,   -3,      -3,       -3,   -3,    - 4.5,        0)), ncol = 2)

 p =  semPaths(model_BG,  what = "std", whatLabels = 'no',#layout = ly2, 
               residuals = F, edge.label.cex = 0, borders = F, vTrans = 0,
               node.width = 1)
 
   p_theo =  semPaths(model_BG_init,   whatLabels = 'no', layout = ly2, 
               residuals = F, edge.label.cex = 0, borders = F, vTrans = 0,
               node.width = 1)

 pdf(file = paste('Results/NOSIZE/SEM_BG.pdf', sep = ''), width = 5)
 plot(p)
 dev.off()
```


### Use the parameters defined in the simple SEM

```{r, eval = FALSE, echo = FALSE, warning=FALSE, eval = T,fig.show="hold", out.width="80%"}
# list trophic levels, AG and BG
trophic_lvls = c( "LUI" = "LUI",
                  "plant" = 0, 
                       "Arth_herb" = 1,
                  "Arth_herb_below" = 2,
                       "But"  = 1,  
                       "Arth_omnicarni" = 2,
                       "Arth_omnicarni_below" = 3,
                       "Bact_fungi"  = 1,  
                       "Protists_patho"  = 1, 
                    #   "Mites"  = 2, 
                       "Coll"  = 2, 
                       "BirdsI"  = 3,  
                       "Bats"  = 3
                      )

  # Extract standardized parameters
  paramsAG <- data.table(lavaan::standardizedSolution(model_AG))
  paramsBG <- data.table(lavaan::standardizedSolution(model_BG))
  
  # Edge properties: keep only unique roaws to have only 1 from LUI to plants
  param_edges <- unique(rbind(paramsAG[op %in% c("=~", "~", "~~") & lhs != rhs,
                          list(to = lhs,
                          from = rhs,
                          val = round(est.std, 2),
                          pval = round(pvalue,6),
                          type = fcase(
                                        op == "=~", "loading",
                                        op == "~" ,"regression",
                                        op == "~~", "correlation",
                                        TRUE, NA_character_))],
       paramsBG[op %in% c("=~", "~", "~~") & lhs != rhs & est.std != 0,
                            list(to = lhs,
                                 from = rhs,
                                 val = round(est.std, 2),
                                 pval = round(pvalue,6),
                                 type = fcase(
                                   op == "=~", "loading",
                                   op == "~" ,"regression",
                                   op == "~~", "correlation",
                                   TRUE, NA_character_))]))
 

  # Node properties
  param_nodes <- unique(rbind(paramsAG[lhs == rhs, list(metric = lhs, e = round(est.std, 2))],
                       paramsBG[lhs == rhs,        list(metric = lhs, e = round(est.std, 2))]))
  param_nodes = param_nodes#[-1,] # remove one of plant-LUI

  
  # Complete Graph Object
  param_graph <- tidygraph::tbl_graph(param_nodes, param_edges)

  
  library(scales)
  # Plot
   layout_all <- matrix(c(
# Pl1  aherb  but     Arth_omni  BirdsI  bats LUI   Mic     Pro1    Mites ,    Prob;    Pro2    Coll  , Arth_carni
c(4,    5,       3,      3,        3,      5,  -2 , #4, 
  3.5,   4.5,            4.5,    4     ),
c(0,    1.5,    1.5,     3,        4.5,   4.5,  0 ,# 0, 
  -1.5,  -1.5,        -3,    -5  )), ncol = 2)

   
gg_fullSEM =  ggraph(param_graph, layout = layout_all)+
          # Correlation Paths (no text)
    geom_edge_link(aes(color = ifelse(type == 'correlation', 1, NA)),
                   linetype = 'dotted', angle_calc = "along",
                   arrow = arrow(type = "closed", unit(.3, "cm"), ends = "both"),
                   end_cap = circle(1.1, 'cm'), start_cap = circle(1.1, 'cm')) +
    geom_edge_link(aes(color = ifelse(type == 'correlation', NA, val),
                     alpha = as.numeric(pval < 0.05)),
                     edge_width = 0,
                     angle_calc = "along", vjust = -.5,
                     arrow = arrow(type = "closed", 50, unit(.5, "cm")),
                     end_cap = circle(0.7, 'cm'),
                     start_cap = circle(0.7, 'cm')) +
    geom_edge_link(aes(color = ifelse(type == 'correlation', NA, val),
                      edge_width = abs(val),
                      linetype = ifelse(type == 'correlation', NA, pval > 0.05),
                      alpha = as.numeric(pval < 0.05)
                      ),
                 angle_calc = "along", vjust = -.5,
                 lineend = "square",linejoin = 'bevel',
                 end_cap = circle(1.1, 'cm'),
                 start_cap = circle(1.1, 'cm')) +

    scale_edge_alpha(guide = FALSE, range = c(0.5, 1)) +
    scale_size(guide = FALSE) +
    theme_graph(base_size = 1, base_family = 'Helvetica') +
  theme(legend.position = 'none')+
    #scale_edge_linetype_manual(#breaks = c(TRUE, FALSE), labels = c('p<0.05', 'p>0.05'), 
    #                    #values = c('solid', 'dashed'), name = "Significance", 
    #  guide = FALSE, na.value = "blank") +
    scale_size_continuous(range = c(0.1, 1), breaks=pretty_breaks(5),  name = 'Estimate') +
    scale_edge_colour_gradient2(low = '#c51b7d', high = '#4d9221', mid = '#ffffbf', na.value = "white",midpoint = 0, breaks=pretty_breaks(5), name = 'Estimate') 

gg_fullSEM

 ggsave(gg_fullSEM, file = 
           paste('Results/NOSIZE/SEM_All.pdf', sep = ''), width = 8, height = 10)

predef_par = rbind(
           data.table(parameterEstimates(model_BG, boot.ci.type ='basic'))[op == ':=', .SD, .SDcols = c("label" , "pvalue" ,"est",  "ci.lower" , 'se',  "ci.upper")][
               , where := 'BG',
             ],
                   data.table(parameterEstimates(model_AG, boot.ci.type ='basic'))[op == ':=', .SD, .SDcols = c("label" , "pvalue" ,"est",  "ci.lower" , 'se',  "ci.upper")][
              , where := 'AG',
             ])

predef_par[!grepl('mean', label), c('In_Direct', 'Driver', 'Group', 'Trophic_lvl') := tstrsplit(gsub('\\.', '_', label), split = '__')]
predef_par$Trophic_lvl = as.numeric(predef_par$Trophic_lvl)
predef_par[is.na(Trophic_lvl), c('Trophic_lvl', 'Group') := list(Group, NA)]




# Get overall estimate of direct, indirect, total effect
library(fishmethods)
predef_par[!is.na(Group) & In_Direct == 'Total', combinevar(est, se*se, n = rep(150,  length(est)))]
predef_par[!is.na(Group) & In_Direct == 'Direct', combinevar(est, se*se, n = rep(150,  length(est)))]
predef_par[!is.na(Group) & In_Direct == 'Indirect', combinevar(est, se*se, n = rep(150,  length(est)))]

# We have 1 estimate but to CI for plants, we use the largest
predef_par[grepl('__0', label), c('est','ci.lower','ci.upper', 'se') := list(min(est), min(ci.lower), max(ci.upper), se = max(se)), by = label]
predef_par = predef_par[!(grepl('__0', label) & where =='BG'),]

data_to_plot = predef_par[is.na(Group),]
data_to_plot[, Yend := ifelse(where == 'BG', -Trophic_lvl, Trophic_lvl)]

# All effects together
library(scales)
gg_effects = ggplot() +
  geom_edges(data=data_to_plot, arrow = arrow( type = "closed",ends = "last",length = unit(0.1, "inches")),
             aes(x = 0, xend = 1, y = 0+Yend/8,yend = Yend, linetype = pvalue>0.05, color = est, size = abs(est))) +
  theme_blank(base_size = 5) + 
  theme(legend.position = 'bottom',legend.direction = 'horizontal') +
    facet_wrap(~In_Direct, ncol = 1) +
  scale_linetype(breaks = c(TRUE, FALSE), labels = c('p>0.05', 'p<0.05'), name = "Significance") +
  scale_size_continuous(range = c(0.5, 4), breaks=pretty_breaks(5),  name = 'Estimate') +
  guides(color = guide_legend(direction = "horizontal",
      title.position = "top"), size = guide_legend(direction = "horizontal",
      title.position = "top"),
       linetype = guide_legend(direction = "horizontal",
      title.position = "top")) +
  theme_blank()+  theme(legend.position = 'bottom', panel.spacing = unit(1.5, "lines"),
                        strip.text.x = element_text( size = 6, color = "NA"),
                        strip.background = element_rect(
     color="white", fill="white", size=1.5, linetype="solid"
     ))+
  xlab('Trophic level') + ylab('Direct LUI effects')+
  scale_color_gradient2(low = '#c51b7d', high = '#4d9221', mid = '#ffffbf', na.value = "white",midpoint = 0, breaks=pretty_breaks(5), name = 'Estimate') 

gg_effects
ggsave(gg_effects, file =  paste('Results/NOSIZE/gg_SEM_effects.pdf', sep = ''), width = 5, height = 12)

formula <- y ~ x
gg_individual_groups = ggplot(data=predef_par[!is.na(Group) ,], aes(x = Trophic_lvl, y = est, ymin = ci.lower, ymax = ci.upper)) +
  geom_smooth(formula = formula, method = "lm", mapping = aes(weight = 1/se), 
              color = "black", show.legend = FALSE)+
  geom_point( position = position_dodge(width = 0.3), aes( group = Group)) +
  geom_errorbar(width = 0.1, position = position_dodge(width = 0.3), aes(group = Group))+
  facet_wrap(~In_Direct, ncol = 1) +
  theme_bw() +
theme(legend.position = 'bottom', panel.spacing = unit(1.5, "lines"),
                        strip.text.x = element_text( size = 6, color = "NA"),
                        strip.background = element_rect(
     color="white", fill="white", size=1.5, linetype="solid"
     )) + xlab('Trophic level') + ylab('Estimate') +
  stat_poly_eq(aes(label = paste(paste(..eq.label.., ..rr.label.., sep = "~~~"),  stat(p.value.label), sep = ' ~~~')), 
               label.x.npc = "left", label.y.npc = 0.1,
               formula = formula, parse = TRUE, size = 3)

ggsave(gg_individual_groups, file =  paste('Results/NOSIZE/gg_individual_groups.pdf', sep = ''), width = 5, height = 12)

```



```{r, eval = FALSE, echo = FALSE, warning=FALSE, eval = T,fig.show="hold", out.width="80%"}

### Import functions dataset
# load datasets
additional_info <- fread('Data/Environment_function_data/27087_21_Dataset/synthesis_grassland_function_metadata_ID27087.csv')
additional_info <- additional_info[, .(ColumnName, AggregatedColumnName, codedYear)]
setnames(additional_info, old = c("ColumnName", "codedYear"), new = c("variable", "Year"))
original_synth_func <- fread('Data/Environment_function_data/27087_21_Dataset/27087_21_data.csv')

# get function-year combinations as columns
# make format even longer to obtain a column "Year" and a column "function"
synth_func <- melt.data.table(original_synth_func, id.vars = c("Plot", "Plotn", "Explo", "Year"))
sum(is.na(synth_func$value))
# delete all missing function-year combinations (without excluding NA values)
synth_func <- synth_func[!value %in% "NM"]
sum(is.na(synth_func$value))

synth_func <- merge(synth_func, additional_info, by = c("variable", "Year"))
synth_func <- synth_func[, .(AggregatedColumnName, Plot, Plotn, Explo, value)]
synth_func <-dcast.data.table(synth_func, Plot + Plotn + Explo ~ AggregatedColumnName, value.var = "value")
synth_func[, colnames(synth_func)[4:87] := lapply(.SD, as.numeric), .SDcols = colnames(synth_func)[4:87]]
setkey(synth_func, 'Plot')

## Also the respiration dataset
Resp = fread('Data/Environment_function_data/26908_4_Dataset/26908_4_data.csv')
Resp[, Plot := ifelse(nchar(EP_Plotid) == 5, EP_Plotid, paste(substr(EP_Plotid, 1, 3), '0', substr(EP_Plotid, 4, 4), sep = ''))]

EF_clean = synth_func[, list(Plot = ifelse(nchar(Plot) == 5, Plot, paste(substr(Plot, 1, 3), 0, substr(Plot, 4, 4),sep = '')),
                          Dung.decomposition = as.numeric(scale(dung.removal)),
                          Litter.decomposition =  as.numeric(scale(Litter.decomposition)),
                          Root.decomposition=  as.numeric(scale(Root.decomposition)),
                          Biomass.production = as.numeric(scale(Biomass)),
                          'Urease'= as.numeric(scale(sqrt(Urease))),
                          'DEA'= as.numeric(scale(sqrt(DEA))),
                          'Potential.nitrification'= as.numeric(scale(sqrt(Potential.nitrification2011)))+
                            as.numeric(scale(Potential.nitrification2014)),
                          'nifH'= as.numeric(scale(sqrt(nifH))),
                          'amoA_AOB'= as.numeric(scale(sqrt(amoA_AOB.2011 + amoA_AOB.2016))),
                          'amoA_AOA'= as.numeric(scale(sqrt(amoA_AOA.2011 + amoA_AOA.2016))),
                          'nxrA_NS'=  as.numeric(scale(sqrt(nxrA_NS))),
                          'n16S_NB'=  as.numeric(scale(sqrt(`16S_NB`))),
                          'beta_Glucosidase' = as.numeric(scale(sqrt(beta_Glucosidase))),
                          'N_Acetyl_beta_Glucosaminidase' = as.numeric(scale(sqrt(N_Acetyl_beta_Glucosaminidase))),
                          'Xylosidase' = as.numeric(scale(sqrt(Xylosidase))),
                          'Phosphatase' = as.numeric(scale(log(Phosphatase)))
                          )
                           ]
EF_clean = merge.data.table(EF_clean, Resp[!grepl('W', Plot),  list(Respiration = mean(Rs)), by = Plot])

# Check % of NAs
EF_clean[, lapply(.SD, function(x){length(x[is.na(x)])/length(x)})]

EF_clean_mice = data.table(mice::complete(mice(EF_clean, printFlag = F, method = 'mean')))
#EF_clean_mice = merge(EF_clean_mice, multi.rich[, list('Plot' = Plot, 'multidiv' = m)], by = 'Plot')
EF_clean_corr = corrections(EF_clean_mice,  Env_data = env_data_lui,  env_corr = env_corr, env_variables = c(env_var, 'Region'))
EF_clean_corr = merge(EF_clean_corr, env_data_lui[, list(LUI, Fertilisation, Disturbance, Plot)])

variables_names_all = c(
                    'DEA',  # Nitrate flux bundle
                    'nifH',  # Nitrate flux bundle
                    'nxrA_NS',  # Nitrate flux bundle
                    'n16S_NB', # Nitrate flux bundle
                    
                    'Urease', # Ammmonia flux bundle
                    'amoA_AOB', # Ammmonia flux bundle
                    'amoA_AOA', # Ammmonia flux bundle
                     
                    'Potential.nitrification',

                    'beta_Glucosidase', # C flux bundle
                    'N_Acetyl_beta_Glucosaminidase', # C flux bundle
                    'Xylosidase',  # C flux bundle
                    
                    'Dung.decomposition', # Decomposition bundle
                    'Litter.decomposition',# Decomposition bundle
                    'Root.decomposition',# Decomposition bundle
                    'Biomass.production', 
                    'Respiration')
# weight for bundles
var_weights = c(rep(1/8,8), rep(1/3,3),rep(1/3,3), 1, 1)

# PCA all vars
pca_mf = PCA(EF_clean_corr[, .SD, .SDcols = c('LUI', 'Disturbance', 'Fertilisation', variables_names_all)], col.w = var_weights, quanti.sup = 1:3)

 if (env_corr == TRUE){
fun_pca = fviz_pca(pca_mf, title = '', geom = 'point', geom.var = c("arrow"), col.quanti.sup = 'darkred', col.var = 'grey30')
}
if (env_corr == FALSE){
fun_pca = fviz_pca(pca_mf, title = '', geom = 'point', geom.var = c("arrow"), habillage = factor(substr(env_data_lui$Region, 1, 1)), col.quanti.sup = 'darkred', col.var = 'grey30')+
  scale_shape_discrete( breaks = c('A', 'H', 'S'), labels = c('South', 'Central', 'North'), name = 'Region')+
  scale_color_viridis(discrete = TRUE, begin = 0.3, breaks = c('A', 'H', 'S'), labels = c('South', 'Central', 'North'), name = 'Region') 
}
   

 pdf(file = paste('Results/NOSIZE/PCA_functions.pdf', sep = ''), width = 6, height = 4)
fun_pca
 dev.off()

 if (env_corr == TRUE){
   fun_pca = fviz_pca(pca_mf, title = '', geom = 'point', geom.var = c('text', "arrow"), col.quanti.sup = 'darkred', col.var = 'grey30', repel = T)
 }
 
  if (env_corr == FALSE){
    fun_pca = fviz_pca(pca_mf, title = '', geom = 'point', geom.var = c('text', "arrow"), habillage = factor(substr(env_data_lui$Region, 1, 1)), col.quanti.sup = 'darkred', col.var = 'grey30', repel = T)+
  scale_shape_discrete( breaks = c('A', 'H', 'S'), labels = c('South', 'Central', 'North'), name = 'Region')+
    scale_color_viridis(discrete = TRUE, begin = 0.3, breaks = c('A', 'H', 'S'), labels = c('South', 'Central', 'North'), name = 'Region') 
 }


 pdf(file = paste('Results/NOSIZE/PCA_functions_wtext.pdf', sep = ''), width = 6, height = 4)
fun_pca
 dev.off()

pca_main = data.frame(PCA_pca$ind$coord)
colnames(pca_main) = paste(colnames(pca_main), '_all', sep = '')
pca_main$Plot = dd$Plot

pca_functions = data.frame(pca_mf$ind$coord)
colnames(pca_functions) = paste(colnames(pca_functions), '_fun', sep = '')
pca_functions$Plot = EF_clean_corr$Plot

pca_plants = data.frame(pca_plants_all$PCA$ind$coord)
pca_plants[,1]= pca_plants[,1] * pca_plants_all$direction # Check that positive is fast

colnames(pca_plants) = paste(colnames(pca_plants), '_plants', sep = '')
pca_plants$Plot = rownames(pca_plants)

pca_bact_fungi = data.frame(pca_mic$PCA$ind$coord)
pca_bact_fungi[,1]= pca_bact_fungi[,1] * pca_mic$direction # Check that positive is fast
colnames(pca_bact_fungi) = paste(colnames(pca_bact_fungi), '_mic', sep = '')
pca_bact_fungi$Plot = rownames(pca_bact_fungi)

dat = merge(EF_clean_corr[, lapply(.SD, mean, na.rm = T), by = Plot], pca_main, by = 'Plot', all = T)
dat = merge(dat, pca_functions, by = 'Plot')
dat = merge(dat, pca_plants, by = 'Plot')
dat = merge(dat, pca_bact_fungi, by = 'Plot')
#dat = merge(dat, env_data_lui[, c('Plot', 'LUI')], by = 'Plot')


dat[, LUI := scale(LUI)]
dat[, cor.test(Dim.1_all, Dim.1_fun)]
dat[, cor.test(LUI, Dim.1_mic)]

mod_all = step(lm(Dim.1_fun~ Dim.1_all , data = dat), trace = -1)
mod_mic = lm(Dim.1_fun ~ Dim.1_mic , data = dat)
mod_plants = step(lm(Dim.1_fun~  Dim.1_plants, data = dat), trace = -1)
mod_lui = step(lm(Dim.1_fun~  LUI, data = dat), trace = -1)

output_model = function(model){
  slope_sd = paste(round(coefficients(summary(model))[2, 1], 2), ' (', round(coefficients(summary(model))[2, 2], 2), ')', sep = '')
  p = coefficients(summary(model))[2, 4]
  r2 = round(summary(model)$adj.r.squared, 2)
  
  return(c(slope_sd, p, r2))
  }

model_table = data.frame(matrix(c(
                   'Functions slow-fast ~ entire community slow-fast', output_model(mod_all),
                   'Functions slow-fast ~ plants slow-fast', output_model(mod_plants),
                   'Functions slow-fast ~ bacteria and fungi slow-fast', output_model(mod_mic),
                   'Functions slow-fast ~ LUI',output_model(mod_lui)), ncol = 4, byrow = T))

colnames(model_table) = c('Model', 'Estimate (sd)', 'Pval', 'R2')
model_table$adj.P = p.adjust(as.numeric(model_table$Pval), 'fdr')
print(model_table)


sem_functions <- ' # direct effect
             Dim.1_fun ~ d*LUI
           # mediator
             Dim.1_fun ~ a*Dim.1_all
             Dim.1_all ~ b*LUI
           # indirect effect (a*b)
             indirect := a*b
           # total effect
             total := d + (a*b)

# diff
diff := indirect - d
         '
         
mod_function = sem(sem_functions, data = dat, se = 'bootstrap')
summary(mod_function)
parameterestimates(mod_function, rsquare = TRUE)

layout_fun = matrix(c(c(2, 1, 0),
                      c(0, 1, 0)), ncol = 2)
 p =  semPaths(mod_function,  what = "std",layout = layout_fun, 
               nodeLabels = c('Functions\n fast-slow', 'Traits\n fast-slow', 'Land-use\nintensity'),
               residuals = F,
               edge.label.cex = 1.5, 
               borders = F,
               node.width = 3)

 
  semtable_lui <- semTable(mod_function, fits = c('pvalue', 'rmsea', 'cfi', 'bic'), print.results = FALSE, type = 'csv',paste('Results/NOSIZE/SEM_table_lui.csv', sep = ''))
  
  
 png(file = paste('Results/NOSIZE/SEM_functions.png', sep = ''), width = 600, height = 400)
 plot(p)
 dev.off()

```
