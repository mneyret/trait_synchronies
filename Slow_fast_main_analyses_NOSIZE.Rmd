---
title: "Slow-fast continuum without size data"
output:
  html_document:
    df_print: paged
  pdf_document: default
---


```{r Set-up options, echo = F}
knitr::opts_knit$set(root.dir = "/Users/margot/Desktop/Research/Senckenberg/Project_Ecosystem_strat/Analysis/Code")
```

```{r Setup Libraries and parameters, echo = FALSE, include = FALSE}
# Libraries
library(forcats) # v 1.0.0
library(ade4) # v 1.7-22
library(scales)  # v 1.2.1
library(factoextra) # v 1.0.7
library(ggfortify) # v 0.4.15 
library(ggcorrplot) # v 0.1.4
library(lavaan) # v 0.6-14 
library(fishmethods) # v 1.12-0  
library(semPlot) # v 1.1.6
library(mice) # v 3.15.0
library(miceFast) # v 0.8.2 
library(ggnetwork) # v 0.5.12 
library(viridis) # v 0.6.2
library(tidygraph) # v 1.2.3
library(ggraph) # v 2.1.0 
library(ggpmisc) # v 0.5.2
library(semTable) # v 1.8
library(FactoMineR) # v 2.7
library(data.table) # v 1.14.8  
library(readxl) # v 1.4.2 
#https://teunbrand.github.io/ggh4x/articles/Facets.html
library(ggh4x) # v 0.2.3
library(kableExtra) # v 1.3.4 
library(phyloseq) # v 
library(parameters) # v 0.21.3  
library(vegan) # v 2.6-4 
library(rsq)
library(car)

# Options and seeds
env_corr <- TRUE 
weight = TRUE

seed = 101

# Colors
pal.fnc = colorRamp(c('#4575b4','#91bfdb','#e0f3f8','#fee090','#fc8d59',
                      '#d73027'))
```
This script demonstrate the analysis conducted for the manuscript "A fast-slow trait continuum at the level of entire communities" by Neyret et al. It should be run after all CWM tables are created (Create_CWM_table.R).

Author: Margot Neyret - Please get in touch if you have questions.

The script loads CWM, environmental covariates and ecosystem functions data to
  - test the relationship of individual traits with land-use intensity (LUI)
  - run PCAs to identify guild- and whole community-level slow-fast axes
  - run SEMs to test whether the slow-fast axes of individual guilds are due to direct LUI effects or indirect, cascading effects
  - test the relation between trait slow-fast and ecosystem functions slow-fast axes.
  - THIS IS NOT THE DEFAULT ANALYSIS. Here all size-related data are disregarded.

Parameters can be changed at the top of the script. Current parameters are: environmental correction is `r env_corr`; weighting for abundances is  `r weight`.


```{r Defining functions, echo = FALSE, include = FALSE}
source('Functions.R')
```

```{r Data loading, echo = FALSE, include = FALSE}
# In this chunk:
# Load CWM and environmental datasets


# Load and format LUI data and environment data
env = load_env_data()
env_data = env[[1]]
env_data_lui = env[[2]]
env_var = env[[3]]
data_lui_raw = env[[4]]
```

```{r Correct data for environmental covariates, echo = FALSE, include = FALSE}
# In this chunk:
# Load CWM and environmental datasets

# Load weighted or unweighted CWM dataset depending on the weight parameter (default = TRUE)
if (weight == TRUE){
all_cwm_raw = fread('Data/CWM_data/All_CWM_data.csv')
}
if (weight == FALSE){
all_cwm_raw = fread('Data/CWM_data/All_CWM_data_noweight.csv')
}

# Selection of traits to be used in the analysis
traits_to_use = traits_use =c( # birds
       "birds_logBody_Mass",        "birds_logIncub_time",       "birds_logLongevity" ,            "birds_logBrood",    'birds_GenLength',          
  # Bats
  "bats_logBody_mass"  ,         "bats_Lifespan"                , 'bats_Number_offspring',             
  # Plants 
  "plants_LDMC", "plants_LeafN", "plants_LeafP", "plants_Root_tissue_density", "plants_SLA_all", "plants_Seed_mass",
             # Most arthropods
  "arthropods_below_omni_carni_Dispersal_ability", "arthropods_below_omni_carni_logBody_Size", 
"arthropods_below_herb_Dispersal_ability", "arthropods_below_herb_logBody_Size", 
"arthropods_below_herb_Feeding_generalism", "arthropods_above_carni_Dispersal_ability", 
"arthropods_above_carni_logBody_Size", "arthropods_above_herb_Dispersal_ability", 
"arthropods_above_herb_logBody_Size", "arthropods_above_herb_Feeding_generalism", 
"arthropods_above_herb_Generations", 
              # Butterflies
"butterflies_logFlight", 'butterflies_logSize',
"butterflies_Wintering_stage", "butterflies_Generalism_use", 
"butterflies_Voltinism_use", 
              # Collembola and mites 
"coll_logSize", "coll_Gen_per_year", "coll_Depth_preference",  "coll_Repro_sex", 
"mites_logMass", "mites_Feeding_spec", 
"mites_Habitat_spec", "mites_Repro_sex", 
"mites_DaystoAdult", 
              # Bacteria and fungi
 "bact_fungi_logVolume", "bact_fungi_OC_ratio", "bact_fungi_FB_ratio", "bact_fungi_pathogens", 'bact_fungi_Genome_size',
              # Protists
"protists_sec_cons_Size", "protists_bact_Size",  "protists_nutrition_code_primary_cons"
)

# Selection of only grassland plots if use of the full dataset
all_cwm_raw = all_cwm_raw[traitName2 %in% traits_to_use & grepl('G', Plot),]
 # all_cwm_raw  will be used to calculate correlations of traits with LUI, group-level PCAs, and non-gap-filled main PCA -> it is  corrected for the environment (if env_corr == TRUE) but not gap-filled

all_cwm = copy(all_cwm_raw) # This one will be used to run guild-level PCAs to feed into the big PCA and SEM, it is gap-filled and corrected for the environment (if env_corr == TRUE)

all_traits = unique(all_cwm_raw$traitName2)

# Aggregate by plot
all_cwm_agg = all_cwm_raw[Year != 2020 | is.na(Year) , list(traitValue = mean(traitValue, na.rm = T), traitCoverage = mean(traitCoverage, na.rm = T)), by = c('Plot', 'traitName','Group', 'traitName2')] # check trait coverage: % of abundance for which trait is available
all_cwm_agg[!is.na(traitValue), length(unique(Plot)), by = Group] # How many plots available for use

# Add environmental covariates
all_cwm_lui = merge.data.table(all_cwm_agg, env_data_lui) 

# Scale all trait data
all_cwm_lui[, traitValue := scale(traitValue), by = c('Group','traitName2')]
all_cwm_lui = all_cwm_lui[order(Group, traitName2, Plot),]

# Fill gaps with environmental covariates (except LUI)
mice_long = function(traitname, covar, data){
  print(nrow(data))
  all_var_cast = dcast.data.table(data, ... ~ traitName2, value.var = 'traitValue', .SDcols = c(traitname, covar, 'Plot'))
  all_var_mice = data.table(mice::complete(mice(all_var_cast, printFlag = FALSE, seed = 101)))
  all_var_melt =  melt.data.table(all_var_mice, id.vars = c(covar, 'Plot'), value.name = 'traitValue', variable.name = 'traitName2')
    print(nrow(all_var_melt))
  return(all_var_melt[order(traitName2, Plot), traitValue])
}

all_cwm_lui[, traitValue2 := mice_long(traitName2, env_var, .SD), .SDcols = c('traitName2', 'traitValue', env_var, 'Plot'), by = Group]

# Correct for environmental covariates
all_cwm_lui[, traitValue3 := corrections_long(traitValue2, .SD, env_corr), .SDcols = c(env_var, 'Region'), by = c('Group', 'traitName')]

all_cwm_lui[, value := traitValue3]

 # We can also put back as NA the gap-filled values
all_cwm_lui_not_imputed = copy(all_cwm_lui)
all_cwm_lui_not_imputed[is.na(traitValue), value := NA]

 # This is the datasets to be used
all_cwm = dcast.data.table( all_cwm_lui, Plot  + LUI + Disturbance + Fertilisation ~ traitName2, value.var = 'value' )
all_cwm_not_imputed = dcast.data.table(all_cwm_lui_not_imputed, Plot  + LUI + Disturbance + Fertilisation~ traitName2, value.var = 'value' )
```

# Check variation in LUI and CWM between years and plots for groups sampled multiple times

```{r Check variation in LUI and CWM between years and plots for groups sampled multiple times, echo = FALSE, include = FALSE}
modLUI = varpart(data_lui_raw[Year > 2007 & Year <= 2018, LUI], 
             data_lui_raw[Year > 2007 & Year <= 2018, factor(PLOTID)],
             data_lui_raw[Year > 2007 & Year <= 2018, factor(Year)])

varpart_results = data.table(Group='LUI', Plot = round(modLUI$part$fract$Adj.R.squared[1], 3), 
                                          Year = round(modLUI$part$fract$Adj.R.squared[2], 3), 
                                     Shared = round(modLUI$part$indfract$Adj.R.squared[3], 3),
                                   Residuals = round(modLUI$part$indfract$Adj.R.squared[4], 3))
# Find groups with more than one year
multiyear_group = all_cwm_raw[, length(unique(Year)), by = Group][V1>1, Group]

# We keep the bacteria + fungi for 2017 out as only one trait is available that year (fungi:bacteria ratio)
for (group in multiyear_group){
  data_cast = dcast(all_cwm_raw[Group == group & !(Year == 2017 & group == "Bact_fun"),], Plot + Year ~ traitName, value.var = 'traitValue')
                    
D = mice::complete(mice(data_cast, seed=101))
mod <- varpart(D[, -c(1,2)], factor(D$Plot), factor(D$Year))

varpart_results = rbind(varpart_results,
                        data.table(Group=group, 
                                   Plot = round(mod$part$fract$Adj.R.squared[1], 3), 
                                   Year = round(mod$part$fract$Adj.R.squared[2], 3),
                                   Shared = round(mod$part$indfract$Adj.R.squared[3], 3),
                                   Residuals = round(mod$part$indfract$Adj.R.squared[4], 3)))}
```

## Hypotheses

Check hypotheses between traits and land-use intensity
```{r Trait-land use intensity table, echo = FALSE, eval = TRUE}
# In this chunk I calculate all trait correlations with land-use intensity and check whether they fit with our hypotheses 
 LUI_component_effect = all_cwm_lui_not_imputed[, calculate_coeff_new(.SD), by = traitName2, .SDcols = c('Grazing', 'Mowing','Fertil', 'Fertilisation', 'Disturbance','value', #'value_uncorr', 
 'LUI')]
Hypothesis_table = fread('Hypotheses.txt')

Hypothesis_table = Hypothesis_table[Trait_short %in% LUI_component_effect$traitName2 & Use =='y',]

Hypothesis_table[, nrows := 1:nrow(Hypothesis_table)]

# Adding values
Hypothesis_table[Group != '', c("P", "Est", "CI","CI_low", 'CI_high', 'N', 'r2', 'Mowing', 'Grazing', 'Fertil' ) :=
  list(
    round(LUI_component_effect[traitName2 == Trait_short, p], 5),
    round(LUI_component_effect[traitName2 == Trait_short, estimate], 2),
    LUI_component_effect[traitName2 == Trait_short, ci],
    LUI_component_effect[traitName2 == Trait_short, ci_low],
    LUI_component_effect[traitName2 == Trait_short, ci_high],
    LUI_component_effect[traitName2 == Trait_short, n],
        round(LUI_component_effect[traitName2 == Trait_short, r2], 2),
    round(LUI_component_effect[traitName2 == Trait_short, Mowing], 2),
    round(LUI_component_effect[traitName2 == Trait_short, Grazing], 2),
    round(LUI_component_effect[traitName2 == Trait_short, Fertil ], 2)
    ), by = nrows]
    
 Hypothesis_table[,c('Direction'
                      ) := list(
     ifelse(Expected_direction == '+/-',  ifelse(Est > 0, 'a', 'b'),
         ifelse((Est > 0 & Expected_direction ==  "++") | (Est < 0 & Expected_direction ==  "--"), "yes", "no"))      )]

  Hypothesis_table[, Padj := p.adjust(P, 'fdr')]
Hypothesis_table[, Signif := ifelse(Padj < 0.05, 'YES', ifelse(P < 0.05, 'yes', 'no'))]

    Hypothesis_table[,c('Fit_expectations') := list(
     ifelse(Padj > 0.05, 'Inconclusive',
            ifelse(Expected_direction == '+/-',  ifelse(Est > 0, 'As expected (fast)', 'As expected (slow)'),
         ifelse(Est > 0 & Expected_direction ==  "++",  'As expected (fast)',
             ifelse(Est < 0 & Expected_direction ==  "--", 'As expected (slow)', "Not expected"))))
      )]

Hypothesis_table[,  Fit_exp := return_hypo_result_color(Signif, Direction), by = 1:nrow(Hypothesis_table)]

responding_traits = Hypothesis_table[ Fit_exp != 'Inconclusive' & Direction != "no", Trait_short]
print_table(Hypothesis_table)
```

```{r Setup trait codes / trait labels, echo = FALSE, warning=FALSE, eval = T,fig.show="hold", out.width="50%"}
all_plant_traits = c("plants_LDMC" , "plants_LeafN", "plants_LeafP", "plants_Seed_mass", "plants_SLA_all" , "plants_Root_tissue_density")
labels_plants =  c("LDMC",  "Leaf N",  "Leaf P",  "Seed mass", "SLA", 'Root tissue density')

traits_Bact_fungi = c("bact_fungi_Genome_size"  , 
                  "bact_fungi_OC_ratio" , "bact_fungi_FB_ratio" ,"bact_fungi_pathogens" )
labels_Bact_fungi =  c("Genome size (bacteria)"  ,   "Oligotrophic:copiotrophic ratio (bacteria)" ,   "Fungi:bacteria ratio" ,  "Proportion plant pathogen (fungi)" )

traits_Arthropods_above_herb = c("arthropods_above_herb_Dispersal_ability",        "arthropods_above_herb_Feeding_generalism",    "arthropods_above_herb_Generations")
labels_arthro_herb =  c("Dispersal"     ,         "Generalism"  ,        "Gen. per year"  )

traits_Arthropods_below_herb = c("arthropods_below_herb_Dispersal_ability",  "arthropods_below_herb_Feeding_generalism")
labels_arthro_below_herb =  c("Dispersal", 'Generalism')

traits_Butterflies = c("butterflies_Generalism_use",    "butterflies_Voltinism_use", "butterflies_Wintering_stage", "butterflies_logFlight")
labels_but =  c("Generalism",   "Voltinism" , "Hibernation stage",  "Flight period"     )

traits_Arthropods_above_omni_carni = c('arthropods_above_carni_Dispersal_ability')
labels_arthro_omni_carni = c('Dispersal')

traits_Arthropods_below_omni_carni = c('arthropods_below_omni_carni_Dispersal_ability')
labels_arthro_below_omni_carni = c('Dispersal')

traits_Birds_insect = c(     "birds_logIncub_time"    ,   "birds_logBrood",      "birds_GenLength" ) 
birds_labels = c( 'Incubation time', 'Offspring max',  'Generation time')

traits_Mites_all = c( "mites_Habitat_spec",  "mites_Repro_sex" ,  "mites_Feeding_spec","mites_DaystoAdult"     )
mites_labels = c('Habitat specialisation', 'Sexual repro',  'Feeding specialisation', 'Days to adult')

traits_Coll_all = c(   "coll_Depth_preference", "coll_Gen_per_year"   ,    "coll_Repro_sex" )
col_labels = c( 'Depth preference', 'Generations per year', 'Sexual reproduction')

traits_Bats =c(   "bats_Lifespan"   ,      "bats_Number_offspring")
bats_labels = c( 'Lifespan', 'Offspring')

```

# Run PCA on all traits, downweighted by the number of each trait per group so that each groups has equal weight
```{r PCA with all traits, echo = FALSE, warning=FALSE, eval = T,fig.show="hold", out.width="50%"}
cwm_cast = dcast(all_cwm_lui[traitName2 %in% Hypothesis_table$Trait_short], Plot + LUI ~ traitName2, value.var =  'value')
cwm_cast$birds_GenLength = log(cwm_cast$birds_GenLength )
new_col = c('Plot','LUI', c(letters, LETTERS)[1:(ncol(cwm_cast)-2)])
names(new_col) = colnames(cwm_cast)

# Weight traits by 1/n traits in the group to give same weight to all groups
weight.data = all_cwm_lui[traitName2 %in% Hypothesis_table$Trait_short, list(trait = unique(traitName2), weight = 1/length(unique(traitName2))), by = Group]
weights = weight.data$weight; names(weights) = weight.data$trait
pca_all = PCA(cwm_cast[,-1], col.w = weights[colnames(cwm_cast[,-c(1,2)])], quanti.sup = 1)

# Change labels
rownames(pca_all$var$coord) =new_col[rownames(pca_all$var$coord)]
rownames(pca_all$var$cor) =new_col[rownames(pca_all$var$cor)]
rownames(pca_all$var$cos2) =new_col[rownames(pca_all$var$cos2)]
rownames(pca_all$var$contrib) =new_col[rownames(pca_all$var$contrib)]

slow_fast_expecations = Hypothesis_table$Expected_direction
names(slow_fast_expecations) = Hypothesis_table$Trait_short
pca_all_traits = fviz_pca(pca_all, repel = T, geom.ind = 'point', axes = c(1,2),  col.quanti.sup = 'darkred', col.var = slow_fast_expecations[colnames(cwm_cast)[-c(1,2)]],
                          palette = c('#3e4989', '#35b779'), title = '') + theme(legend.position = 'none')


ggsave(plot = pca_all_traits,file = paste('Results/Envcorr_', env_corr, '/weight_', weight,'/PCA_All_traits.pdf', sep = ''), width = 8, height = 5)
```

## Draw individual trait responses to LUI
```{r Draw PCA with all traits, echo = FALSE, eval = TRUE}
Hypothesis_table[, Group_f := Group]
Hypothesis_table$Group_f = factor(Hypothesis_table$Group_f, levels=c( 'arthropods_above_carni','birds', 'bats',
'plants','arthropods_above_herb','butterflies',
         'bact_fungi',"protists",          "protists_bact" ,    "protists_sec_cons", 'coll','mites','arthropods_below_herb', 'arthropods_below_omni_carni'))

recode_key = c(labels_plants,
              "Genome size\n(bacteria)"      ,              
   "Oligotrophic:copiotrophic\nratio (bacteria)" ,"Fungi:bacteria\nratio"   ,                   
   "Proportion plant\npathogen (fungi)"  ,       
                     labels_arthro_herb, labels_but, 
                     labels_arthro_omni_carni, labels_arthro_below_herb, 
                     labels_arthro_below_omni_carni, bats_labels,
                     birds_labels, 
   "Depth\npreference"   ,  "Generations\nper year", "Sexual\nreproduction" ,#col_labels, 
               mites_labels,
               '% Primary\nconsumers')

names(recode_key)  <- c(all_plant_traits, traits_Bact_fungi, traits_Arthropods_above_herb, traits_Butterflies, traits_Arthropods_above_omni_carni,traits_Arthropods_below_herb, 
traits_Arthropods_below_omni_carni, traits_Bats, 
traits_Birds_insect, 
traits_Coll_all, traits_Mites_all, 
'protists_nutrition_code_primary_cons')

Hypothesis_table[, labels := dplyr::recode(Trait_short, !!!recode_key)]

design <- matrix(c(1,2,3,
                   4, 5, 6,
                   7, 8, 11,
                   7, 9, 11,
                   7, 10, 11,
                   12, 13, 14), ncol = 3, byrow = TRUE)

plot_traits = ggplot(Hypothesis_table, aes(x = reorder(labels, -Est), y = Est, ymin = CI_low, ymax = CI_high, color = Fit_expectations)) + geom_point(size = 3) + geom_errorbar(width = 0.4, size = 1.5) + 
  facet_manual(~Group_f,  scales = 'free',  strip.position = 'top', design = design, heights = c(4, 4, 1, 1, 1, 4)) +
  ylim(c(-0.55, 0.7)) +
  
  coord_flip() + theme_bw() + geom_hline(yintercept = 0) +
  scale_color_manual(breaks = c('Inconclusive', 'As expected (fast)', 'As expected (slow)', 'Not expected'), values = c('grey',   '#35b779','#3e4989',  '#cf4446')) + 
  ylab('') + xlab('') +
      theme(legend.position = 'none',
            strip.text.x = element_text(size=13, hjust = -1, color = 'transparent'),
            strip.text.y = element_text(size=2, face="bold"),
            strip.background = element_rect( fill="transparent", color = 'transparent'),
         # strip.color = element_rect( fill="transparent"),
            panel.background = element_rect(fill='transparent'),
          plot.background = element_rect(fill='transparent', color=NA),
          panel.grid.minor = element_blank(),
          legend.background = element_rect(fill='transparent'),
          legend.box.background = element_rect(fill='transparent'),
         panel.spacing = unit(1.2, "lines")
      )+ 
  geom_text(data = Hypothesis_table[!grepl('protists',Group_f),list(N = paste(unique(N), collapse = '/')), by = Group_f], aes(x = -Inf, y = -Inf, label = paste('N =', N)), inherit.aes = FALSE, vjust = -0.3,
  hjust = -0.3, size = 3)
plot_traits

ggsave(plot_traits,file = 
           paste('Results/NOSIZE/plot_traits.pdf', sep = ''), width = 10, height = 8)

## Other possibility
#all_cwm_melt = melt.data.table(all_cwm_not_imputed[, .SD, .SDcols = c('Plot', 'LUI', 'Disturbance', 'Fertilisation', #colnames(all_cwm_not_imputed)[colnames(all_cwm_not_imputed) %in% Hypothesis_table$Trait_short])], 
#                               id.vars = c('Plot', 'LUI', 'Disturbance', 'Fertilisation'), variable.name = 'traitName', value.name = 'traitValue')
#all_cwm_melt[, Group := tstrsplit(traitName,'_' )[1], by = traitName]
```

# Identification of slow-fast axes for each group

### Plants, above- and below-ground
Axis 1 is slow -> fast
```{r Plants, echo = FALSE, warning=FALSE, eval = T,fig.show="hold", out.width="50%"}
pca_plants_all = run_group_pca(env_corr = env_corr, all_cwm_not_imputed, all_plant_traits ,Labels =labels_plants, 'plants_SLA_all')
pca_plants_all$plot12

ggsave(plot = pca_plants_all$plot12,file = paste('Results/NOSIZE/Plant_com_pca.pdf', sep = ''), width = 4.5, height = 4.5)

```

## Bacteria & fungi
Axis 1 is slow -> fast
```{r "Bacteria and fungi", eval=T, echo=FALSE, fig.show="hold", message=FALSE, warning=FALSE, out.width="50%"}
pca_mic = run_group_pca(env_corr = env_corr, all_cwm_not_imputed, traits_Bact_fungi, 'bact_fungi_pathogens',  Labels = labels_Bact_fungi)
pca_mic$plot12

ggsave(plot = pca_mic$plot12, file = paste('Results/NOSIZE/bact_fungi_OCm_pca.pdf', sep = ''), width = 4.5, height = 4.5)
```

## Arthropods herbivores (below- and above-ground, incl. butterflies)
In all cases axis 1 is slow -> fast, butterflies size is a bit off due to its measurement as wing size which is both a body size and dispersal trait

```{r, echo = FALSE, warning=FALSE, eval = T,fig.show="hold", out.width="50%"}
# Above-ground arthropods

pca_arthro_herb = run_group_pca(env_corr = env_corr, all_cwm_not_imputed, traits_Arthropods_above_herb, 'arthropods_above_herb_Dispersal_ability', Labels = labels_arthro_herb)
pca_arthro_herb$plot12
ggsave(plot = pca_arthro_herb$plot12, file = paste('Results/NOSIZE/Arthro_herb_AG_com_pca.pdf', sep = ''), width = 4.5, height = 4.5)
# Check which axis is the slow-fast: it is the one where dispersal and size are anticorrelated
if (prod(pca_arthro_herb$PCA$var$coord[c( 'arthropods_above_herb_Feeding_generalism'), 'Dim.1']) < 0) {axis_arthro_herb = 1}
if (prod(pca_arthro_herb$PCA$var$coord[c( 'arthropods_above_herb_Feeding_generalism'), 'Dim.2']) < 0) {axis_arthro_herb = 2}

# Below-ground arthropods
pca_arthro_herb_below = run_group_pca(env_corr = env_corr, all_cwm_not_imputed, traits_Arthropods_below_herb, 'arthropods_below_herb_Dispersal_ability', Labels = labels_arthro_below_herb)

pca_arthro_herb_below$plot12  = pca_arthro_herb_below$plot12 + ylim(c(-5, 4))
pca_arthro_herb_below$criteria
  
ggsave(plot = pca_arthro_herb_below$plot12,file =
         paste('Results/NOSIZE/Arthro_herb_BG_com_pca.pdf', sep = ''), width = 4.5, height = 4.5)

# Butterflies
pca_but = run_group_pca(env_corr = env_corr, all_cwm_not_imputed, Labels = labels_but, traits_Butterflies, 'butterflies_logFlight')
pca_but$plot12
pca_but$criteria

ggsave(plot = pca_but$plot12, file = paste('Results/NOSIZE/Butterflies_com_pca.pdf', sep = ''), width = 4.5, height = 4.5)
```

### Arthropods, predators

Only one trait: dispersal


## Birds

Axis 1 = slow -> fast axis
```{r Birds, echo = FALSE, warning=FALSE, eval = T,fig.show="hold", out.width="50%"}
pca_birds_all= run_group_pca(env_corr = env_corr, all_cwm_not_imputed, traits_Birds_insect, 'birds_logBrood', Labels = birds_labels)
pca_birds_all$plot12
pca_birds_all$criteria

ggsave(plot = pca_birds_all$plot12,file =  paste('Results/NOSIZE/Birds_i_com_pca.pdf', sep = ''), width = 4.5, height = 4.5)
```

## Mites & collembola
Axis 1 = slow -> fast axis
```{r Mites, echo = FALSE, warning=FALSE, eval = T,fig.show="hold", out.width="50%"}
pca_mites_all = run_group_pca(env_corr = env_corr, all_cwm_not_imputed, traits_Mites_all, 'mites_DaystoAdult', direction = '<0', Labels = mites_labels)
pca_mites_all$plot12
pca_mites_all$plot13

ggsave(plot = pca_mites_all$plot12,file = 
         paste('Results/NOSIZE/Mites_com_pca.pdf', sep = ''), width = 4.5, height = 4.5)
```

Collembola: axis 1 = slow -> fast axis

```{r Collembola, echo = FALSE, warning=FALSE, eval = T,fig.show="hold", out.width="50%"}
pca_coll_all = run_group_pca(env_corr = env_corr, all_cwm_not_imputed, traits_Coll_all, 'coll_Depth_preference',  Labels = col_labels)
pca_coll_all$plot12
pca_coll_all$plot13
pca_coll_all$criteria

ggsave(plot = pca_coll_all$plot12, file = paste('Results/NOSIZE/Coll_com_pca.pdf', sep = ''), width = 4.5, height = 4.5)

```

## Bats
Bats: axis 1 = slow -> fast axis
```{r Bats, echo = FALSE, warning=FALSE, eval = T,fig.show="hold", out.width="50%"}
pca_bats_all = run_group_pca(env_corr = env_corr, all_cwm_not_imputed, traits_Bats, 'bats_Number_offspring', Labels = bats_labels)
pca_bats_all$plot12
pca_bats_all$plot13
pca_bats_all$criteria

ggsave(plot = pca_bats_all$plot12,file = paste('Results/NOSIZE/Bats_com_pca.pdf', sep = ''), width = 4.5, height = 4.5)
```

# Assemble data for further analysis
## Check Correlation between axes and LUI
```{r Check axes criteria and correlations to LUI, echo = FALSE, warning=FALSE, eval = T,fig.show="hold", out.width="80%"}

#### Check the criteria for PCAs: do they represent a slow-fast axis?
criterias = rbind(pca_plants_all$criteria[, Group := 'plants'],
           pca_arthro_herb$criteria[, Group := 'arthro_herb'],
           pca_arthro_herb_below$criteria[, Group := 'arthro_herb_below'],
          # pca_arthro_pred$criteria[, Group := 'arthro_pred'],
           #pca_arthro_pred_below$criteria[, Group := 'arthro_pred_below'],
           pca_mic$criteria[, Group := 'mic'],
           pca_mites_all$criteria[, Group := 'mites'],
           pca_coll_all$criteria[, Group := 'coll'],
           pca_but$criteria[, Group := 'butterflies'],
           pca_birds_all$criteria[, Group := 'birds'],
           pca_bats_all$criteria[, Group := 'bats'])

print(criterias)

#### Put all the PCA axes together to compare correlations to LUI. 
# In some casis the slow-fast axis is multiplied by -1 so that increasing axis values means hypothetically faster system (this is just a normalisation step, as the direction of PCA axes is somewhat random)

### Now subset it to only fast-slow axes, multiplied by direction so that the axis goes from slow to fast
# Check how much variance is explained by each slow-fast axis: axis 1 for all groups except above-ground arthro omni carni, for which it's sometimes axis 2 (checked by parameter axis_arthro_pred)
prop = c( plant = pca_plants_all$PCA$eig[,2][ 1],
         Arth_herb = pca_arthro_herb$PCA$eig[,2][axis_arthro_herb], 
        (Arth_herb_below = pca_arthro_herb_below$PCA$eig[,2][1]),
       # (Arth_omnicarni= pca_arthro_pred$PCA$eig[,2][axis_arthro_pred]),
       # (Arth_omnicarni_below = pca_arthro_pred_below$PCA$eig[,2][ 1]),
        (Bact_fungi = pca_mic$PCA$eig[,2][ 1]),
        (Mites = pca_mites_all$PCA$eig[,2][ 1]),
        (Coll = pca_coll_all$PCA$eig[,2][ 1]),
        (But  = pca_but$PCA$eig[,2][1]),
        (BirdsI  = pca_birds_all$PCA$eig[,2][ 1]),
        (Bats = pca_bats_all$PCA$eig[,2][ 1]))
print(paste(c('Average variance explained by slow-fast axis:', round(mean(prop),1), '+/-', round(sd(prop), 1)), collapse = ' '))

# Put all slow-fast axes in one dataset. the parameter $direction checks that we take the correct direction for each axis (faster = higher values)
dd = Reduce(function(...) merge(..., all = TRUE, by = 'Plot'), 
  list(
    data.table(plant = pca_plants_all$PCA$ind$coord[, 1]*pca_plants_all$direction,
                   Plot  = rownames(pca_plants_all$PCA$ind$coord)),
        data.table(Arth_herb = pca_arthro_herb$PCA$ind$coord[, axis_arthro_herb]*pca_arthro_herb$direction, # When the data is not weighted by abundance, the fast-slow axis of herbivorous arthropods above-ground is on PC2
                   Plot = rownames(pca_arthro_herb$PCA$ind$coord)),
        data.table(Arth_herb_below = pca_arthro_herb_below$PCA$ind$coord[, 1]*pca_arthro_herb_below$direction , 
                   Plot = rownames(pca_arthro_herb_below$PCA$ind$coord)),
        data.table(Arth_omnicarni= all_cwm$arthropods_above_carni_Dispersal_ability, 
                   Plot = all_cwm$Plot),
        data.table(Arth_omnicarni_below = all_cwm$arthropods_below_omni_carni_Dispersal_ability, 
                   Plot = all_cwm$Plot),
        data.table(Bact_fungi = pca_mic$PCA$ind$coord[, 1]*pca_mic$direction, 
                   Plot = rownames(pca_mic$PCA$ind$coord)),
        data.table(Protists_patho =  all_cwm$protists_nutrition_code_primary_cons,    
                   Plot =  all_cwm$Plot),
        #data.table(Mites = pca_mites_all$PCA$ind$coord[, 1]*pca_mites_all$direction, 
       #            Plot = rownames(pca_mites_all$PCA$ind$coord)),
        data.table(Coll = pca_coll_all$PCA$ind$coord[, 1]*pca_coll_all$direction, 
                   Plot = rownames(pca_coll_all$PCA$ind$coord)),
        data.table(But  = pca_but$PCA$ind$coord[, 1]*pca_but$direction, 
                   Plot = rownames(pca_but$PCA$ind$coord)),
        data.table(BirdsI  = pca_birds_all$PCA$ind$coord[, 1]*pca_birds_all$direction, 
                   Plot = rownames(pca_birds_all$PCA$ind$coord)),
        data.table(Bats = pca_bats_all$PCA$ind$coord[, 1]*pca_bats_all$direction, 
                   Plot = rownames( pca_bats_all$PCA$ind$coord)),
        env_data_lui[,.SD, .SDcols = c('LUI', 'Fertil', 'Mowing', 'Grazing', "Disturbance", "Fertilisation",'Plot')]))


all_col = colnames(dd)[-1]

# Scale all columns so tht all weight the same in the PCA and SEMs
dd[, (all_col) := lapply(.SD, function(x){as.numeric(scale(x))}), .SDcols = all_col]
  
# Then we gap-fill the dataset. This will be used only in the main slow-fast PCA, not in the SEMs (which can handle missing values)
dd_miced =   mice::complete(mice(dd[,  c('LUI', "Disturbance", "Fertilisation", "plant", "Arth_herb", "Arth_herb_below",
                           "Arth_omnicarni", 
                           "Arth_omnicarni_below","Bact_fungi",  "Protists_patho", # "Mites", 
                           "Coll", "But",   "BirdsI",  "Bats")], printFlag = FALSE, method = 'mean'))

PCA_pca_LUI = PCA(dd_miced[,  c('LUI', "plant", "Arth_herb",
                           "Arth_omnicarni", 
                           "Arth_omnicarni_below","Bact_fungi",  "Protists_patho",  # "Mites", 
                           "Coll", "But",   "BirdsI",  "Bats")], quanti.sup = 1)

PCA_pca = PCA(dd_miced[,  c('LUI', "Disturbance", "Fertilisation", "plant", "Arth_herb",
                           "Arth_omnicarni", 
                           "Arth_omnicarni_below","Bact_fungi",  "Protists_patho",  # "Mites",
                           "Coll", "But",   "BirdsI",  "Bats")], quanti.sup = 1:3)

# We do different plots with or without the individual LUI components as additional variables.
# If env_corr is FALSE, the points are colored by region. If TRUE, region has already been corrected for.
if (env_corr == FALSE){
pca_pca_plot = fviz_pca(PCA_pca, geom =c("point"), geom.var = c('arrow', 'text'), col.quanti.sup = 'darkred', col.var = 'grey30',
                       habillage = factor(substr(env_data_lui[Plot %in% dd$Plot,Plot], 1, 1)),
                        palette = viridis(3, begin = 0.3), repel = TRUE)
pca_pca_plot_nolabel = fviz_pca(PCA_pca, geom =c("point"), geom.var = c('arrow'), col.quanti.sup = 'darkred', col.var = 'grey30',
                      habillage = factor(substr(env_data_lui[Plot %in% dd$Plot,Plot], 1, 1)), palette = viridis(3, begin = 0.3), repel = TRUE)

pca_pca_plot_LUI = fviz_pca(PCA_pca_LUI, geom =c("point"), geom.var = c('arrow'), col.quanti.sup = 'darkred', col.var = 'grey30',
                       habillage = factor(substr(env_data_lui[Plot %in% dd$Plot,Plot], 1, 1)),
                       palette = viridis(3, begin = 0.3), repel = TRUE)}
if (env_corr == TRUE){
pca_pca_plot = fviz_pca(PCA_pca, geom =c("point"), geom.var = c('arrow', 'text'), col.quanti.sup = 'darkred', col.var = 'grey30',
                        repel = TRUE)
pca_pca_plot_nolabel = fviz_pca(PCA_pca, geom =c("point"),geom.var = c('arrow'), col.quanti.sup = 'darkred', col.var = 'grey30',
                      repel = TRUE)

pca_pca_plot_LUI = fviz_pca(PCA_pca_LUI, geom =c("point"),geom.var = c('arrow'), col.quanti.sup = 'darkred', col.var = 'grey30',
                       repel = TRUE)}

# Save the plots
ggsave(plot = pca_pca_plot ,file = paste('Results/NOSIZE/All_groups_pca.pdf', sep = ''), width = 8, height = 6)
ggsave(plot = pca_pca_plot_LUI, file = paste('Results/NOSIZE/All_groups_pca_LUI_nolabel.pdf', sep = ''), width = 8, height = 6)
ggsave(plot = pca_pca_plot_nolabel, file = paste('Results/NOSIZE/All_groups_pca_nolabel.pdf', sep = ''), width = 8, height = 6)

# Test correlation between PCA axis 1 and LUI
a = cor.test(PCA_pca$ind$coord[, 1], env_data_lui[Plot %in% dd$Plot,]$LUI)
print(paste('Correlation between overall slow-fast axis and LUI:', round(a$estimate, 2), ', pvalue =', a$p.value))
```


# Run SEM

## Define trophic levels
```{r Define trophic levels, eval = FALSE, echo = FALSE, warning=FALSE, eval = T,fig.show="hold", out.width="80%"}
Trophic_levels = list( "plant" = 0, 
                       "Arth_herb" = 1,
                      #"Arth_herb_below" = 2,
                       "But"  = 1,  
                       "Arth_omnicarni" = 2,
                       "Arth_omnicarni_below" = 3,
                       "Bact_fungi"  = 1,  
                       "Protists_patho"  = 1,  
                      # "Protists_bact"  = 2, 
                      # "Protists_sec" = 2,  
                      # "Mites"  = 2, 
                       "Coll"  = 2, 
                       "BirdsI"  = 3,  
                       "Bats"  = 3
                      )
```

## Run above-ground model
```{r Above-ground SEM, eval = FALSE, echo = FALSE, warning=FALSE, eval = T,fig.show="hold", out.width="80%"}
# All SEM models are run twice: the first to setup the basic model equation and the second (with autowrite_SEM_full) so that the direct/indirect effects etc are also quantified. The second time is also bootstrapped to get confidence intervals.

# First run
mod_AG =  "
        plant ~ LUI 
        
        Arth_herb ~ LUI  + plant   
        But       ~ LUI  + plant  

        Arth_omnicarni ~ LUI + plant + But + Arth_herb
        BirdsI ~ LUI + plant + But + Arth_herb + Arth_omnicarni
        Bats ~   LUI + plant + But + Arth_herb + Arth_omnicarni
      
        Bats ~~ BirdsI
"
 model_init_AG <- sem(mod_AG, data = dd)

 # Full run
 model_AG = sem(paste(autowrite_SEM_full(model_init_AG, Trophic_levels), 'Bats ~~ BirdsI', sep = '\n'),
                dd,
                estimator = "ML",
                missing = "ML",
                se = 'bootstrap', bootstrap = 200
                )
 
  # Save model output
 semtable_AG <- semTable (model_AG, fits = c('pvalue', 'rmsea', 'cfi', 'bic'), print.results = FALSE, type = 'csv', paste('Results/NOSIZE/SEM_table_AG.csv', sep = ''))
 
 fitmeasures(model_AG, c("cfi", "rmsea", "rmsea.ci.upper", "bic"))
 # Plot model
 ## Theoretical model
 #  p_theo =  semPaths(model_init_AG,   whatLabels = 'no', layout = layout_AG, 
 #             residuals = F, edge.label.cex = 0, borders = F, vTrans = 0,
 #             node.width = 1)
 
 layout_AG <- matrix(c(
# Pl1      aherb     but     Arth_omni       BirdsI    bats    LUI
c(4,          5,       3,      3,              3,      5,       -2),
c(0,          1.5,    1.5,     3,              4.5,   4.5,      0 )), ncol = 2)
  ## Model results
 p =  semPaths(model_AG,  what = "std", whatLabels = 'no', #layout = layout_AG, 
               residuals = F, edge.label.cex = 0, borders = F, vTrans = 0,
               node.width = 1)
 pdf(file = paste('Results/NOSIZE/SEM_AG.pdf', sep = ''), width = 5)
 plot(p)
 dev.off()
```

## Run below-ground model

```{r Below-grund SEM, eval = FALSE, echo = FALSE, warning=FALSE, eval = T,fig.show="hold", out.width="80%"}
# First run
mod_BG =  "
        plant ~ LUI 
        
        Protists_patho  ~ LUI + plant
        Bact_fungi   ~      LUI + plant
        Coll   ~          LUI + plant + Bact_fungi 

        Arth_omnicarni_below ~ LUI  + Coll 
"
 model_BG_init <- sem(mod_BG,
    data = dd)
  summary(model_BG_init, standardized = TRUE)

# Full run
model_BG = sem(paste(autowrite_SEM_full(model_BG_init, Trophic_levels), 'Protists_patho ~~ Bact_fungi \n Protists_patho ~~ 0*Arth_omnicarni_below', sep = '\n'),
                dd,  
                estimator = "ML",
                missing = "ML",
                se = 'bootstrap', bootstrap = 200
               )
 
 # Get model output
 semtable_BG <- semTable (model_BG, fits = c('pvalue', 'rmsea', 'cfi', 'bic'), print.results = FALSE, type = 'csv',paste('Results/NOSIZE/SEM_table_BG.csv', sep = ''))
 
 fitmeasures(model_BG, c("cfi", "rmsea", "rmsea.ci.upper", "bic"))

 # Plot model
 ly2 <- matrix(c(
# Pl1   Mic  Pro1    Mites ,   Prob;    Pro2    Coll  , Arth_herb_below, Arth_carni  LUI
c(4,    3.5,  4.5,   5.5,     3.5,      2.5,     4.5,      4,    -2),
c(0, -1.5,  -1.5,   -3,      -3,       -3,   -3,    - 4.5,        0)), ncol = 2)

  ## Theoretical model 
 #   p_theo =  semPaths(model_BG_init,   whatLabels = 'no', layout = ly2, 
 #               residuals = F, edge.label.cex = 0, borders = F, vTrans = 0,
 #               node.width = 1)
 
 ##  Model results 
 p =  semPaths(model_BG,  what = "std", whatLabels = 'no',#layout = ly2, 
               residuals = F, edge.label.cex = 0, borders = F, vTrans = 0,
               node.width = 1)
 
 pdf(file = paste('Results/NOSIZE/SEM_BG.pdf', sep = ''), width = 5)
 plot(p)
 dev.off()
```


### Analyse and plot the SEM

```{r Get parameters from SEMs, eval = FALSE, echo = FALSE, warning=FALSE, eval = T,fig.show="hold", out.width="80%"}
# list trophic levels, AG and BG
trophic_lvls = c( "LUI" = "LUI", Trophic_levels)

  # Extract standardized parameters
  paramsAG <- data.table(lavaan::standardizedSolution(model_AG))
  paramsBG <- data.table(lavaan::standardizedSolution(model_BG))
  
  # Edge properties: keep only unique rows to have only 1 from LUI to plants
  param_edges <- unique(rbind(paramsAG[op %in% c("=~", "~", "~~") & lhs != rhs,
                          list(to = lhs,
                          from = rhs,
                          val = round(est.std, 2),
                          pval = round(pvalue,6),
                          type = fcase(
                                        op == "=~", "loading",
                                        op == "~" ,"regression",
                                        op == "~~", "correlation",
                                        TRUE, NA_character_))],
       paramsBG[op %in% c("=~", "~", "~~") & lhs != rhs & est.std != 0,
                            list(to = lhs,
                                 from = rhs,
                                 val = round(est.std, 2),
                                 pval = round(pvalue,6),
                                 type = fcase(
                                   op == "=~", "loading",
                                   op == "~" ,"regression",
                                   op == "~~", "correlation",
                                   TRUE, NA_character_))]))
 

  # Node properties
  param_nodes <- unique(rbind(paramsAG[lhs == rhs, list(metric = lhs, e = round(est.std, 2))],
                       paramsBG[lhs == rhs,        list(metric = lhs, e = round(est.std, 2))]))
  param_nodes = param_nodes#[-1,] # remove one of plant-LUI
```

```{r Plot full SEM, eval = FALSE, echo = FALSE, warning=FALSE, eval = T,fig.show="hold", out.width="80%"}
  # Complete Graph Object
  param_graph <- tidygraph::tbl_graph(param_nodes, param_edges)

    # Plot
   layout_all <- matrix(c(
# Pl1  aherb  but     Arth_omni  BirdsI  bats LUI   Mic     Pro1    Mites ,    Prob;    Pro2    Coll  , Arth_carni
c(4,    5,       3,      3,        3,      5,  -2 , #4, 
  3.5,   4.5,            4.5,    4     ),
c(0,    1.5,    1.5,     3,        4.5,   4.5,  0 ,# 0, 
  -1.5,  -1.5,        -3,    -5  )), ncol = 2)

   
gg_fullSEM =  ggraph(param_graph, layout = layout_all)+
    geom_edge_link(aes(color = ifelse(type == 'correlation', 1, NA)),
                   linetype = 'dotted', angle_calc = "along",
                   arrow = arrow(type = "closed", unit(.3, "cm"), ends = "both"),
                   end_cap = circle(1.1, 'cm'), start_cap = circle(1.1, 'cm')) +
    geom_edge_link(aes(color = ifelse(type == 'correlation', NA, val),
                     alpha = as.numeric(pval < 0.05)),
                     edge_width = 0,
                     angle_calc = "along", vjust = -.5,
                     arrow = arrow(type = "closed", 50, unit(.5, "cm")),
                     end_cap = circle(0.7, 'cm'),
                     start_cap = circle(0.7, 'cm')) +
    geom_edge_link(aes(color = ifelse(type == 'correlation', NA, val),
                      edge_width = abs(val),
                      linetype = ifelse(type == 'correlation', NA, pval > 0.05),
                      alpha = as.numeric(pval < 0.05)
                      ),
                 angle_calc = "along", vjust = -.5,
                 lineend = "square",linejoin = 'bevel',
                 end_cap = circle(1.1, 'cm'),
                 start_cap = circle(1.1, 'cm')) +

    scale_edge_alpha(guide = FALSE, range = c(0.5, 1)) +
    scale_size(guide = FALSE) +
    theme_graph(base_size = 4, base_family = 'Helvetica') +
    theme(legend.position = "none") +
    scale_size_continuous(range = c(0.1, 2), breaks=pretty_breaks(5),  limits = c(-1, 1), name = 'Estimate') +
    scale_edge_colour_gradient2(low = '#c51b7d', high = '#4d9221', mid = '#ffffbf', limits = c(-1, 1), na.value = "white",midpoint = 0, breaks=pretty_breaks(5), name = 'Estimate') 

gg_fullSEM

 ggsave(gg_fullSEM, file = 
           paste('Results/NOSIZE/SEM_All.pdf', sep = ''), width = 8, height = 10)
```
```{r Compare direct/indirect/total SEM effects, eval = FALSE, echo = FALSE, warning=FALSE, eval = T,fig.show="hold", out.width="80%"}
predef_par = rbind(data.table(parameterEstimates(model_BG, boot.ci.type ='basic'))[op == ':=', .SD, .SDcols = c("label" , "pvalue" ,"est",  "ci.lower" , 'se',  "ci.upper")][
               , where := 'BG',
             ],data.table(parameterEstimates(model_AG, boot.ci.type ='basic'))[op == ':=', .SD, .SDcols = c("label" , "pvalue" ,"est",  "ci.lower" , 'se',  "ci.upper")][
              , where := 'AG',])

predef_par[!grepl('mean', label), c('In_Direct', 'Driver', 'Group', 'Trophic_lvl') := tstrsplit(gsub('\\.', '_', label), split = '__')]
predef_par$Trophic_lvl = as.numeric(predef_par$Trophic_lvl)
predef_par[is.na(Trophic_lvl), c('Trophic_lvl', 'Group') := list(Group, NA)]

# Get overall estimate of direct, indirect, total effect
predef_par[!is.na(Group) & In_Direct == 'Total', combinevar(est, se*se, n = rep(150,  length(est)))]
predef_par[!is.na(Group) & In_Direct == 'Direct', combinevar(est, se*se, n = rep(150,  length(est)))]
predef_par[!is.na(Group) & In_Direct == 'Indirect', combinevar(est, se*se, n = rep(150,  length(est)))]

# We have 1 estimate but to CI for plants, we use the largest
predef_par[grepl('__0', label), c('est','ci.lower','ci.upper', 'se') := list(min(est), min(ci.lower), max(ci.upper), se = max(se)), by = label]
predef_par = predef_par[!(grepl('__0', label) & where =='BG'),]

data_to_plot = predef_par[is.na(Group),]
data_to_plot[, Yend := ifelse(where == 'BG', -Trophic_lvl, Trophic_lvl)]

# Plot all effects together
gg_effects = ggplot() +
  geom_edges(data=data_to_plot, arrow = arrow( type = "closed",ends = "last",length = unit(0.1, "inches")),
             aes(x = 0, xend = 1, y = 0+Yend/8,yend = Yend, linetype = pvalue>0.05, color = est, size = abs(est))) +
  theme_blank(base_size = 5) + 
  theme(legend.position = 'bottom',legend.direction = 'horizontal') +
    facet_wrap(~In_Direct, ncol = 1) +
  scale_linetype(breaks = c(TRUE, FALSE), labels = c('p>0.05', 'p<0.05'), name = "Significance") +
  scale_size_continuous(range = c(-0.3, 8.2), breaks=c(0.1, 0.2, 0.3, 0.4, 0.5), limits = c(0, 1), name = 'Estimate') +
  guides(color = guide_legend(direction = "horizontal",
      title.position = "top"), size = guide_legend(direction = "horizontal",
      title.position = "top"),
       linetype = guide_legend(direction = "horizontal",
      title.position = "top")) +
  theme_blank()+  theme(legend.position = 'bottom', panel.spacing = unit(1.5, "lines"),
                        strip.text.x = element_text( size = 6, color = "NA"),
                        strip.background = element_rect(
     color="white", fill="white", size=1.5, linetype="solid"
     )) +
  xlab('Trophic level') + ylab('Direct LUI effects')+
  scale_color_gradient2(low = '#c51b7d', high = '#4d9221', mid = '#ffffbf', limits = c(-1, 1), na.value = "white",midpoint = 0, breaks=c(0.1, 0.2, 0.3, 0.4, 0.5), name = 'Estimate') 

gg_effects
ggsave(gg_effects, file =  paste('Results/NOSIZE/gg_SEM_effects.pdf', sep = ''), width = 5, height = 12)

formula <- y ~ x

predef_par[!is.na(Group) & In_Direct == 'Direct', summary(lm(est ~ Trophic_lvl, weight = 1/se))]


gg_individual_groups = ggplot(data=predef_par[!is.na(Group) ,], aes(x = Trophic_lvl, y = est, ymin = ci.lower, ymax = ci.upper)) +
  geom_smooth(formula = formula, method = "lm", mapping = aes(weight = 1/se), 
              color = "black", show.legend = FALSE)+
  geom_point( position = position_dodge(width = 0.3), aes( group = Group)) +
  geom_errorbar(width = 0.1, position = position_dodge(width = 0.3), aes(group = Group))+
  facet_wrap(~In_Direct, ncol = 1) +
  theme_bw(base_size = 16) +
theme(legend.position = 'bottom', panel.spacing = unit(1.5, "lines"),
                        strip.text.x = element_text( size = 6, color = "NA"),
                        strip.background = element_rect(
     color="white", fill="white", size=1.5, linetype="solid"
     )) +
      xlab('Trophic level') + ylab('Estimate') +
  stat_poly_eq(aes(label = paste(paste(..eq.label.., ..rr.label.., sep = "~~~"),  stat(p.value.label), sep = ' ~~~')), 
                label.x.npc = "left", label.y.npc = 0.05,
               formula = formula, parse = TRUE, size = 5)

ggsave(gg_individual_groups, file =  paste('Results/NOSIZE/gg_individual_groups.pdf', sep = ''), width = 5, height = 12)

```
# Test the relationship between slow-fast traits and ecoststem functions axes

## We are going to compare the response of ecosystem functions to traits and multiple values including multidiversity (Allan et al 2014) so we first need to calculate it

```{r Calculate multidiversity, eval = FALSE, echo = FALSE, warning=FALSE, eval = T,fig.show="hold", out.width="80%"}
if (!exists('multi.rich')){ # this can take a while so if the data was already assembled we don't do it again
source('multidiv.R')
  
# Get diversities dataset ####
## Raw diversity
allsp <- fread("Data/Abundance_data/27707_2_Dataset/27707_2_data.csv")
allsp$Species = gsub('_$', '', allsp$Species ) # Remove _ if last character
## Species information
fgs <- fread("Data/Abundance_data/27706_3_Dataset/27706_3_data.csv")
fgs$Species = gsub(' $', '', fgs$Species )
fgs$Species = gsub(' ', '_', fgs$Species )
Abundance_all <- merge.data.table(allsp, fgs, by ="Species", all.x=TRUE)
Abundance_all[, Plot := ifelse(nchar(Plot) == 5, Plot, paste(substr(Plot, 1, 3), '0', substr(Plot, 4, 4), sep = ''))]

#### Rarefaction for bacteria and fungi ###
### Soil fungi ##
fun.cast<-dcast.data.table(Abundance_all[Group_broad == 'soilfungi', list(value = value, 'Species_Year' = paste(Species, Year), Plot)],Species_Year~Plot,value.var="value",fill=0)
fun.cast_matrix<-as.matrix(fun.cast[,-1])
rownames(fun.cast_matrix)<-fun.cast$Species_Year
fun_spec<-otu_table(fun.cast_matrix, taxa_are_rows = TRUE) # conversion step one for getting a phyloseq object
fun_phylo<-phyloseq(fun_spec) # conversion step two for getting a phyloseq object
Fungi_rarefied <- rarefy_even_depth(fun_phylo,
                                      sample.size = min(sample_sums(fun_phylo)),
                                      rngseed = 1, replace = FALSE, trimOTUs = TRUE,
                                      verbose = TRUE) #sample size should be the smallest number of sequences #per sample
# Transform to usable dataframe/datatable format in the long format
Fungi_rarefied = data.frame(Fungi_rarefied)
Fungi_rarefied_melt = melt.data.table(data.table(Fungi_rarefied)[, c('Species', 'Year') := tstrsplit(rownames(Fungi_rarefied), ' ')],
                                          id.var = c('Species', 'Year'), value.name = 'value', variable.name = 'Plot')

## Soil bacteria ##
bact.cast<-dcast.data.table(Abundance_all[Group_broad == 'bacteria.RNA', list(value = value, 'Species_Year' = paste(Species, Year), Plot)],Species_Year~Plot,value.var="value",fill=0)
bact.cast_matrix<-as.matrix(bact.cast[,-1])
rownames(bact.cast_matrix)<-bact.cast$Species_Year
bact_spec<-otu_table(bact.cast_matrix, taxa_are_rows = TRUE) # conversion step one for getting a phyloseq object
bact_phylo<-phyloseq(bact_spec) # conversion step two for getting a phyloseq object
Bacteria_rarefied <- rarefy_even_depth(bact_phylo,
                                   sample.size = min(sample_sums(bact_phylo)),
                                   rngseed = 1, replace = FALSE, trimOTUs = TRUE,
                                   verbose = TRUE) #sample size should be the smallest number of sequences per #sample
## Transform to usable dataframe/datatable format in the long format
Bacteria_rarefied = data.frame(Bacteria_rarefied)
Bacteria_rarefied_melt = melt.data.table(data.table(Bacteria_rarefied)[, c('Species', 'Year') := tstrsplit(rownames(Bacteria_rarefied), ' ')],
                                    id.var = c('Species', 'Year'), value.name = 'value', variable.name = 'Plot')
##### Overwrite in Abundance dataset
Abundance_all = Abundance_all[!(Group_broad %in% c('soilfungi', 'bacteria.RNA')), .SD, .SDcols = c('Species', 'Plot', 'value', 'Group_broad', 'Year')] # Remove the existing soil fungi data
Abundance_all = rbind(Abundance_all, Fungi_rarefied_melt[, Group_broad := 'soilfungi']) # Re-add the rarefied #fungi data
Abundance_all = rbind(Abundance_all, Bacteria_rarefied_melt[, Group_broad := 'bacteria.RNA']) # Re-add the #rarefied fungi data

allsp.rich= Abundance_all[!(Group_broad %in% c("Hymenoptera", 'Mollusca',"Plant.pathogen",'Diptera"', 'Insect.larvae', 'Myriapoda','Formicidae', "Neuroptera", "Dictyoptera", "Dermaptera", "Opiliones")) & value>0, list(rich =length(unique(Species))), by=c("Plot","Group_broad")] # Calculate how many species with abundance > 0
allsp.rich_cast = dcast.data.table(allsp.rich, Plot~ Group_broad, value.var = 'rich') # Turn into broad format
groups = colnames(allsp.rich_cast)[-1]

### Multidiversity
multi.rich <- cbind(data.table(multidiv(allsp.rich_cast[,..groups])), Plot = allsp.rich_cast$Plot)
}
```

## Check slow-fast effect on ecosystem functions slow-fast

```{r Import and format functions dataset, eval = FALSE, echo = FALSE, warning=FALSE, eval = T,fig.show="hold", out.width="80%"}
EF_clean = load_eco_functions()
```

```{r Get ecosystem functioning slow-fast axis, eval = FALSE, echo = FALSE, warning=FALSE, eval = T,fig.show="hold", out.width="80%"}
# Check % of NAs
EF_clean[, lapply(.SD, function(x){length(x[is.na(x)])/length(x)})]

EF_clean_mice = data.table(mice::complete(mice(EF_clean, printFlag = F, method = 'mean')))
EF_clean_mice = merge(EF_clean_mice, multi.rich[, list('Plot' = Plot, 'multidiv' = m)], by = 'Plot')
EF_clean_corr = corrections(EF_clean_mice,  Env_data = env_data_lui,  env_corr = env_corr, env_variables = c(env_var, 'Region'))
EF_clean_corr = merge(EF_clean_corr, env_data_lui[, list(LUI, Fertilisation, Disturbance, Plot)])

# The ecosystem functions in the PCA needs to be down-weighted so that each bundle of correlated functions (that are part of similar processes) is equally weighted
variables_names_all = c(
                    'DEA',  # Nitrate flux bundle
                    'nifH',  # Nitrate flux bundle
                    'nxrA_NS',  # Nitrate flux bundle
                    'n16S_NB', # Nitrate flux bundle
                    
                    'Urease', # Ammmonia flux bundle
                    'amoA_AOB', # Ammmonia flux bundle
                    'amoA_AOA', # Ammmonia flux bundle
                     
                    'Potential.nitrification',

                    'beta_Glucosidase', # C flux bundle
                    'N_Acetyl_beta_Glucosaminidase', # C flux bundle
                    'Xylosidase',  # C flux bundle
                    
                    'Dung.decomposition', # Decomposition bundle
                    'Litter.decomposition',# Decomposition bundle
                    'Root.decomposition',# Decomposition bundle
                    'Biomass.production', 
                    'Respiration')
# Weight for individual functions as parts of bundles
var_weights = c(rep(1/8,8), rep(1/3,3),rep(1/3,3), 1, 1)

# PCA of all ecosystem functions
pca_mf = PCA(EF_clean_corr[, .SD, .SDcols = c('LUI', 'Disturbance', 'Fertilisation', variables_names_all)], col.w = var_weights, quanti.sup = 1:3)
# Plot the PCA, if env_corr == FALSE the dots are colored by the region
 if (env_corr == TRUE){
fun_pca = fviz_pca(pca_mf, title = '', geom = 'point', geom.var = c("arrow"), col.quanti.sup = 'darkred', col.var = 'grey30')
}
if (env_corr == FALSE){
fun_pca = fviz_pca(pca_mf, title = '', geom = 'point', geom.var = c("arrow"), habillage = factor(substr(env_data_lui$Region, 1, 1)), col.quanti.sup = 'darkred', col.var = 'grey30')+
  scale_shape_discrete( breaks = c('A', 'H', 'S'), labels = c('South', 'Central', 'North'), name = 'Region')+
  scale_color_viridis(discrete = TRUE, begin = 0.3, breaks = c('A', 'H', 'S'), labels = c('South', 'Central', 'North'), name = 'Region') 
}
   
 pdf(file = paste('Results/NOSIZE/PCA_functions.pdf', sep = ''), width = 6, height = 4)
fun_pca
 dev.off()

 # We also save the plot without labels to reuse in figures
 if (env_corr == TRUE){
   fun_pca = fviz_pca(pca_mf, title = '', geom = 'point', geom.var = c('text', "arrow"), col.quanti.sup = 'darkred', col.var = 'grey30', repel = T)
 }
 
  if (env_corr == FALSE){
    fun_pca = fviz_pca(pca_mf, title = '', geom = 'point', geom.var = c('text', "arrow"), habillage = factor(substr(env_data_lui$Region, 1, 1)), col.quanti.sup = 'darkred', col.var = 'grey30', repel = T)+
  scale_shape_discrete( breaks = c('A', 'H', 'S'), labels = c('South', 'Central', 'North'), name = 'Region')+
    scale_color_viridis(discrete = TRUE, begin = 0.3, breaks = c('A', 'H', 'S'), labels = c('South', 'Central', 'North'), name = 'Region') 
 }

 pdf(file = paste('Results/NOSIZE/PCA_functions_wtext.pdf', sep = ''), width = 6, height = 4)
fun_pca
 dev.off()
```

```{r Compare slow-fast ecosystem response to traits, multidiv, LUI etc, eval = FALSE, echo = FALSE, warning=FALSE, eval = T,fig.show="hold", out.width="80%"}
pca_main = data.frame(PCA_pca$ind$coord)
colnames(pca_main) = paste(colnames(pca_main), '_all', sep = '')
pca_main$Plot = dd$Plot

pca_all_traits = data.frame(pca_all$ind$coord) # This is the PCA that takes all traits as input
colnames(pca_all_traits) = paste(colnames(pca_all_traits), '_allTraits', sep = '')
pca_all_traits$Plot = dd$Plot

pca_functions = data.frame(pca_mf$ind$coord)
colnames(pca_functions) = paste(colnames(pca_functions), '_fun', sep = '')
pca_functions$Plot = EF_clean_corr$Plot

pca_plants = data.frame(pca_plants_all$PCA$ind$coord)
pca_plants[,1]= pca_plants[,1] * pca_plants_all$direction # Check that positive values means faster

colnames(pca_plants) = paste(colnames(pca_plants), '_plants', sep = '')
pca_plants$Plot = rownames(pca_plants)

pca_bact_fungi = data.frame(pca_mic$PCA$ind$coord)
pca_bact_fungi[,1]= pca_bact_fungi[,1] * pca_mic$direction # Check that positive values means faster
colnames(pca_bact_fungi) = paste(colnames(pca_bact_fungi), '_mic', sep = '')
pca_bact_fungi$Plot = rownames(pca_bact_fungi)

dat = merge(EF_clean_corr[, lapply(.SD, mean, na.rm = T), by = Plot], pca_main, by = 'Plot', all = T)
dat = merge(dat, pca_functions, by = 'Plot')
dat = merge(dat, pca_plants, by = 'Plot')
dat = merge(dat, pca_bact_fungi, by = 'Plot')
dat = merge(dat, pca_all_traits, by = 'Plot')
dat = merge(dat, all_cwm_not_imputed[, list(bact_fungi_FB_ratio = as.numeric(scale(bact_fungi_FB_ratio)), Plot)], by = 'Plot')

# Scale variables
dat[, LUI := scale(LUI)]
dat[, multidiv := scale(multidiv)]

# Run all models
mod_all = step(lm(Dim.1_fun~ Dim.1_all , data = dat), trace = -1)
mod_allTraits = step(lm(Dim.1_fun~ Dim.1_allTraits , data = dat), trace = -1)
mod_mic = lm(Dim.1_fun ~ Dim.1_mic , data = dat)
mod_plants = step(lm(Dim.1_fun~  Dim.1_plants, data = dat), trace = -1)
mod_div = step(lm(Dim.1_fun~  multidiv, data = dat), trace = -1)
mod_lui = step(lm(Dim.1_fun~  LUI, data = dat), trace = -1)
mod_FB = step(lm(Dim.1_fun~  bact_fungi_FB_ratio, data = dat), trace = -1)

output_model = function(model){
  slope_sd = paste(round(coefficients(summary(model))[2, 1], 2), ' (', round(coefficients(summary(model))[2, 2], 2), ')', sep = '')
  p = coefficients(summary(model))[2, 4]
  r2 = round(summary(model)$adj.r.squared, 2)
  
  return(c(slope_sd, p, r2))
  }

model_table = data.frame(matrix(c(
                   'Functions slow-fast ~ entire community slow-fast', output_model(mod_all),
                   'Functions slow-fast ~ entire community slow-fast with all traits', output_model(mod_allTraits), 
                   'Functions slow-fast ~ plants slow-fast', output_model(mod_plants),
                   'Functions slow-fast ~ bacteria and fungi slow-fast', output_model(mod_mic),
                   'Functions slow-fast ~ LUI',output_model(mod_lui),
                   'Functions slow-fast ~ taxonomic multidiversity', output_model(mod_div),
                   'Functions slow-fast ~ FB ratio', output_model(mod_FB)), ncol = 4, byrow = T))

colnames(model_table) = c('Model', 'Estimate (sd)', 'Pval', 'R2')
model_table$adj.P = p.adjust(as.numeric(model_table$Pval), 'fdr')
print(model_table)

# PCA slow-fast > functions
sem_functions <- ' # direct effect
             Dim.1_fun ~ d*LUI
           # mediator
             Dim.1_fun ~ a*Dim.1_all
             Dim.1_all ~ b*LUI
           # indirect effect (a*b)
             indirect := a*b
           # total effect
             total := d + (a*b)

# diff
diff := indirect - d
         '
         
mod_function = sem(sem_functions, data = dat, se = 'bootstrap')
layout_fun = matrix(c(c(2, 1, 0),
                      c(0, 1, 0)), ncol = 2)
 p =  semPaths(mod_function,  what = "std",layout = layout_fun, 
               nodeLabels = c('Functions\n fast-slow', 'Traits\n fast-slow', 'Land-use\nintensity'),
               residuals = F,
               edge.label.cex = 1.5, 
               borders = F,
               node.width = 3)
 
 png(file = paste('Results/NOSIZE/SEM_functions.png', sep = ''), width = 600, height = 400)
 plot(p)
 dev.off()

```
